<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-xxxxxx-xx');
    </script>
  

  <!-- Baidu Tongji -->
  
    <script type="text/javascript">
      // Originial
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc"/>
  <meta name="baidu-site-verification" content="PpzM9WxOJU"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="It&#39;s an IT blog..."/>
  <meta name="keyword" content="HTML,JavaScript,CSS,TypeScript,VUE,WEBPACK,VITE"/>
  <link rel="shortcut icon" href="/img/avatar/logo.jpg"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css"/>
    <link rel="stylesheet" href="/css/widget.css"/>
    <link rel="stylesheet" href="/css/rocket.css"/>
    <link rel="stylesheet" href="/css/signature.css"/>
    <link rel="stylesheet" href="/css/catalog.css"/>
    <link rel="stylesheet" href="/css/livemylife.css"/>

    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css"/>
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="https://jasonluox.github.io/en/vue3-【源码解读】AST转换/">
  <title>
    
      [vue3 源码解读] AST转换 - 流年风尘 | 我的前端之路
    
  </title>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Jason Luo&#39;s Golden House</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">HOME</a>
          </li>

          
          
          
          
          <li>
            <a href="/about/">
              
              ABOUT
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/archive/">
              
              ARCHIVES
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/categories/">
              
              CATEGORIES
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              TAGS
              
              
            </a>
          </li>
          
          

          
          <li>
            <a class="popup-trigger">
              <span class="search-icon"></span>SEARCH</a>
          </li>
          

          <!-- LangSelect -->
          
          
          
          
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/comic/about_stars3.jpg');
      --intro-header-background-image-url-post: url('/img/header_img/scenery/tree_stars.jpg');
      --intro-header-background-image-url-page: url('//img/header_img/scenery/tree_stars.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/comic/about_stars3.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/scenery/tree_stars.jpg');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('//img/header_img/scenery/tree_stars.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url('/img/header_img/scenery/tree_stars.jpg'); */
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/jasonluo-white.png');
      }
    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading" style="height: 200px;">
            <div class="tags">
              
              <a class="tag" href="/tags/#vue3源码" title="vue3源码">vue3源码</a>
              
              <a class="tag" href="/tags/#vue3" title="vue3">vue3</a>
              
            </div>
            <h1>[vue3 源码解读] AST转换</h1>
            <h2 class="subheading"></h2>
            <span class="meta">
              Posted by Jason Luo on
              2021-09-20
            </span>


<!--            
            &lt;!&ndash; WordCount start &ndash;&gt;
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">43</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">9.8k</span> In Total
            </span>
            <div class="blank_box"></div>
            &lt;!&ndash; WordCount end &ndash;&gt;
            
            
            &lt;!&ndash; 不蒜子统计 start &ndash;&gt;
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            &lt;!&ndash; 不蒜子统计 end &ndash;&gt;
            -->


          </div>
          
        </div>
      </div>
    </div>
  </div>

  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h3 id="源码地址">源码地址</h3>
<blockquote>
<p>本节课的相关代码在源代码中的位置如下：<br>
packages/compiler-core/src/compile.ts<br>
packages/compiler-core/src/transform.ts<br>
packages/compiler-core/src/ast.ts<br>
packages/compiler-core/src/transforms/transformElement.ts<br>
packages/compiler-core/src/transforms/transformExpression.ts</p>
</blockquote>
<p>上一节课，我们学习了 template 的解析过程，最终拿到了一个 AST 节点对象。这个对象是对模板的完整描述，但是它还不能直接拿来生成代码，因为它的语义化还不够，没有包含和编译优化的相关属性，所以还需要进一步转换。</p>
<p>AST 转换过程非常复杂，有非常多的分支逻辑，为了方便你理解它的核心流程，我精心准备了一个示例，我们只分析示例场景在 AST 转换过程中的相关代码逻辑，不过我希望你在学习完之后，可以举一反三，对示例做一些修改，学习更多场景的代码逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;hello v-if&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;hello&gt;</span><br><span class="line">  &lt;div v-else&gt;</span><br><span class="line">    &lt;p&gt;&gt;hello &#123;&#123; msg + test &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;static&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;static&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>示例中，我们有普通的 DOM 节点，有组件节点，有 v-if 指令，有文本节点，也有表达式节点。</p>
<p>对于这个模板，我们通过 parse 生成一个 AST 对象，接下来我们就来分析这个 AST 对象的转换都做了哪些事情。</p>
<p>我们会先通过 getBaseTransformPreset 方法获取节点和指令转换的方法，然后调用 transform 方法做 AST 转换，并且把这些节点和指令的转换方法作为配置的属性参数传入。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取节点和指令转换的方法</span></span><br><span class="line"><span class="keyword">const</span> [nodeTransforms, directiveTransforms] = getBaseTransformPreset()</span><br><span class="line"><span class="comment">// AST 转换</span></span><br><span class="line">transform(ast, extend(&#123;&#125;, options, &#123;</span><br><span class="line">  prefixIdentifiers,</span><br><span class="line">  nodeTransforms: [</span><br><span class="line">    ...nodeTransforms,</span><br><span class="line">    ...(options.nodeTransforms || []) <span class="comment">// 用户自定义  transforms</span></span><br><span class="line">  ],</span><br><span class="line">  directiveTransforms: extend(&#123;&#125;, directiveTransforms, options.directiveTransforms || &#123;&#125; <span class="comment">// 用户自定义 transforms</span></span><br><span class="line">  )</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>我们先来看一下 getBaseTransformPreset 返回哪些节点和指令的转换方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getBaseTransformPreset</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  prefixIdentifiers?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">TransformPreset</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    [</span><br><span class="line">      transformOnce,</span><br><span class="line">      transformIf,</span><br><span class="line">      transformMemo,</span><br><span class="line">      transformFor,</span><br><span class="line">      ...(__COMPAT__ ? [transformFilter] : []),</span><br><span class="line">      ...(!__BROWSER__ &amp;&amp; prefixIdentifiers</span><br><span class="line">        ? [</span><br><span class="line">            <span class="comment">// order is important</span></span><br><span class="line">            trackVForSlotScopes,</span><br><span class="line">            transformExpression</span><br><span class="line">          ]</span><br><span class="line">        : __BROWSER__ &amp;&amp; __DEV__</span><br><span class="line">        ? [transformExpression]</span><br><span class="line">        : []),</span><br><span class="line">      transformSlotOutlet,</span><br><span class="line">      transformElement,</span><br><span class="line">      trackSlotScopes,</span><br><span class="line">      transformText</span><br><span class="line">    ],</span><br><span class="line">    &#123;</span><br><span class="line">      on: transformOn,</span><br><span class="line">      bind: transformBind,</span><br><span class="line">      model: transformModel</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里并不需要你进一步去看每个转换函数的实现，只要大致了解有哪些转换函数即可，这些转换函数会在后续执行 transform 的时候调用。</p>
<blockquote>
<p>注意这里我们只分析在 Node.js 环境下的编译过程。Web 环境的编译结果可能会有一些差别，我们会在后续章节说明。</p>
</blockquote>
<p>我们主要来看 transform 函数的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transform</span>(<span class="params">root: RootNode, options: TransformOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = createTransformContext(root, options)</span><br><span class="line">  traverseNode(root, context)</span><br><span class="line">  <span class="keyword">if</span> (options.hoistStatic) &#123;</span><br><span class="line">    hoistStatic(root, context)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!options.ssr) &#123;</span><br><span class="line">    createRootCodegen(root, context)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// finalize meta information</span></span><br><span class="line">  root.helpers = [...context.helpers.keys()]</span><br><span class="line">  root.components = [...context.components]</span><br><span class="line">  root.directives = [...context.directives]</span><br><span class="line">  root.imports = context.imports</span><br><span class="line">  root.hoists = context.hoists</span><br><span class="line">  root.temps = context.temps</span><br><span class="line">  root.cached = context.cached</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__COMPAT__) &#123;</span><br><span class="line">    root.filters = [...context.filters!]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transform 的核心流程主要有四步：</p>
<ul>
<li>创建 transform 上下文</li>
<li>遍历 AST 节点</li>
<li>静态提升</li>
<li>创建根代码生成节点</li>
</ul>
<h3 id="创建-transform-上下文">创建 transform 上下文</h3>
<p>首先，我们来看创建 transform 上下文的过程，其实和 parse 过程一样，在 transform 阶段会创建一个上下文对象，它的实现过程是这样的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTransformContext</span>(<span class="params">root, &#123; prefixIdentifiers = <span class="literal">false</span>, hoistStatic = <span class="literal">false</span>, cacheHandlers = <span class="literal">false</span>, nodeTransforms = [], directiveTransforms = &#123;&#125;, transformHoist = <span class="literal">null</span>, isBuiltInComponent = NOOP, expressionPlugins = [], scopeId = <span class="literal">null</span>, ssr = <span class="literal">false</span>, onError = defaultOnError &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = &#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    prefixIdentifiers,</span><br><span class="line">    hoistStatic,</span><br><span class="line">    cacheHandlers,</span><br><span class="line">    nodeTransforms,</span><br><span class="line">    directiveTransforms,</span><br><span class="line">    transformHoist,</span><br><span class="line">    isBuiltInComponent,</span><br><span class="line">    expressionPlugins,</span><br><span class="line">    scopeId,</span><br><span class="line">    ssr,</span><br><span class="line">    onError,</span><br><span class="line">    <span class="comment">// 状态数据</span></span><br><span class="line">    root,</span><br><span class="line">    helpers: <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">    components: <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">    directives: <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">    hoists: [],</span><br><span class="line">    imports: <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">    temps: <span class="number">0</span>,</span><br><span class="line">    cached: <span class="number">0</span>,</span><br><span class="line">    identifiers: &#123;&#125;,</span><br><span class="line">    scopes: &#123;</span><br><span class="line">      vFor: <span class="number">0</span>,</span><br><span class="line">      vSlot: <span class="number">0</span>,</span><br><span class="line">      vPre: <span class="number">0</span>,</span><br><span class="line">      vOnce: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    parent: <span class="literal">null</span>,</span><br><span class="line">    currentNode: root,</span><br><span class="line">    childIndex: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// methods</span></span><br><span class="line">    <span class="function"><span class="title">helper</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">      context.helpers.add(name)</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">helperString</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`_<span class="subst">$&#123;helperNameMap[context.helper(name)]&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">replaceNode</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">      context.parent.children[context.childIndex] = context.currentNode = node</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">removeNode</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> list = context.parent.children</span><br><span class="line">      <span class="keyword">const</span> removalIndex = node</span><br><span class="line">        ? list.indexOf(node)</span><br><span class="line">        : context.currentNode</span><br><span class="line">          ? context.childIndex</span><br><span class="line">          : -<span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (!node || node === context.currentNode) &#123;</span><br><span class="line">        <span class="comment">// 移除当前节点</span></span><br><span class="line">        context.currentNode = <span class="literal">null</span></span><br><span class="line">        context.onNodeRemoved()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 移除兄弟节点</span></span><br><span class="line">        <span class="keyword">if</span> (context.childIndex &gt; removalIndex) &#123;</span><br><span class="line">          context.childIndex--</span><br><span class="line">          context.onNodeRemoved()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移除节点</span></span><br><span class="line">      context.parent.children.splice(removalIndex, <span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    onNodeRemoved: <span class="function">() =&gt;</span> &#123; &#125;,</span><br><span class="line">    <span class="function"><span class="title">addIdentifiers</span>(<span class="params">exp</span>)</span> &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">removeIdentifiers</span>(<span class="params">exp</span>)</span> &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">hoist</span>(<span class="params">exp</span>)</span> &#123;</span><br><span class="line">      context.hoists.push(exp)</span><br><span class="line">      <span class="keyword">const</span> identifier = createSimpleExpression(<span class="string">`_hoisted_<span class="subst">$&#123;context.hoists.length&#125;</span>`</span>, <span class="literal">false</span>, exp.loc, <span class="literal">true</span>)</span><br><span class="line">      identifier.hoisted = exp</span><br><span class="line">      <span class="keyword">return</span> identifier</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">cache</span>(<span class="params">exp, isVNode = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createCacheExpression(++context.cached, exp, isVNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，这个上下文对象 context 维护了 transform 过程的一些配置，比如前面提到的节点和指令的转换函数等；还维护了 transform 过程的一些状态数据，比如当前处理的 AST 节点，当前 AST 节点在子节点中的索引，以及当前 AST 节点的父节点等。此外，context 还包含了在转换过程中可能会调用的一些辅助函数，和一些修改 context 对象的方法。</p>
<p>你现在也没必要去了解它的每一个属性和方法的含义，只需要你大致有一个印象即可，未来分析某个具体场景，再回过头了解它们的实现即可。</p>
<p>创建完上下文对象后，接下来就需要遍历 AST 节点。</p>
<h3 id="遍历-AST-节点">遍历 AST 节点</h3>
<p>遍历 AST 节点的过程很关键，因为核心的转换过程就是在遍历中实现的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverseNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  node: RootNode | TemplateChildNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: TransformContext</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  context.currentNode = node</span><br><span class="line">  <span class="comment">// 节点转换函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; nodeTransforms &#125; = context</span><br><span class="line">  <span class="keyword">const</span> exitFns = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodeTransforms.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 有些转换函数会涉及一个退出函数，在处理完子节点后执行</span></span><br><span class="line">    <span class="keyword">const</span> onExit = nodeTransforms[i](node, context)</span><br><span class="line">    <span class="keyword">if</span> (onExit) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isArray(onExit)) &#123;</span><br><span class="line">        exitFns.push(...onExit)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exitFns.push(onExit)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!context.currentNode) &#123;</span><br><span class="line">      <span class="comment">// node was removed</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 因为在转换的过程中节点可能被替代，恢复到之前的节点</span></span><br><span class="line">      node = context.currentNode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (node.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> NodeTypes.COMMENT:</span><br><span class="line">      <span class="keyword">if</span> (!context.ssr) &#123;</span><br><span class="line">        <span class="comment">// inject import for the Comment symbol, which is needed for creating</span></span><br><span class="line">        <span class="comment">// comment nodes with `createVNode`</span></span><br><span class="line">        context.helper(CREATE_COMMENT)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> NodeTypes.INTERPOLATION:</span><br><span class="line">      <span class="comment">// no need to traverse, but we need to inject toString helper</span></span><br><span class="line">      <span class="keyword">if</span> (!context.ssr) &#123;</span><br><span class="line">        context.helper(TO_DISPLAY_STRING)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for container types, further traverse downwards</span></span><br><span class="line">    <span class="keyword">case</span> NodeTypes.IF:</span><br><span class="line">      <span class="comment">// 递归遍历每个分支节点</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.branches.length; i++) &#123;</span><br><span class="line">        traverseNode(node.branches[i], context)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> NodeTypes.IF_BRANCH:</span><br><span class="line">    <span class="keyword">case</span> NodeTypes.FOR:</span><br><span class="line">    <span class="keyword">case</span> NodeTypes.ELEMENT:</span><br><span class="line">    <span class="keyword">case</span> NodeTypes.ROOT:</span><br><span class="line">      <span class="comment">// 遍历子节点</span></span><br><span class="line">      traverseChildren(node, context)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exit transforms</span></span><br><span class="line">  context.currentNode = node</span><br><span class="line">  <span class="keyword">let</span> i = exitFns.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    exitFns[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，traverseNode 函数的基本思路就是递归遍历 AST 节点，针对每个节点执行一系列的转换函数，有些转换函数还会设计一个退出函数，当你执行转换函数后，它会返回一个新函数，然后在你处理完子节点后再执行这些退出函数，这是因为有些逻辑的处理需要依赖子节点的处理结果才能继续执行。</p>
<p>Vue.js 内部大概内置了八种转换函数，分别处理指令、表达式、元素节点、文本节点等不同的特性。限于篇幅，我不会介绍所有转换函数，TODO 感兴趣的同学可以后续自行分析。</p>
<p>下面我会介绍四种类型的转换函数，并结合前面的示例来分析。</p>
<h4 id="Element-节点转换函数">Element 节点转换函数</h4>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transformElement = <span class="function">(<span class="params">node, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(node.type === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> &amp;&amp;</span><br><span class="line">    (node.tagType === <span class="number">0</span> <span class="comment">/* ELEMENT */</span> ||</span><br><span class="line">      node.tagType === <span class="number">1</span> <span class="comment">/* COMPONENT */</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回退出函数，在所有子表达式处理并合并后执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">postTransformElement</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 转换的目标是创建一个实现 VNodeCall 接口的代码生成节点</span></span><br><span class="line">    <span class="keyword">const</span> &#123; tag, props &#125; = node</span><br><span class="line">    <span class="keyword">const</span> isComponent = node.tagType === <span class="number">1</span> <span class="comment">/* COMPONENT */</span></span><br><span class="line">    <span class="keyword">const</span> vnodeTag = isComponent</span><br><span class="line">      ? resolveComponentType(node, context)</span><br><span class="line">      : <span class="string">`&quot;<span class="subst">$&#123;tag&#125;</span>&quot;`</span></span><br><span class="line">    <span class="keyword">const</span> isDynamicComponent = isObject(vnodeTag) &amp;&amp; vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">let</span> vnodeProps</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    <span class="keyword">let</span> vnodeChildren</span><br><span class="line">    <span class="comment">// 标记更新的类型标识，用于运行时优化</span></span><br><span class="line">    <span class="keyword">let</span> vnodePatchFlag</span><br><span class="line">    <span class="keyword">let</span> patchFlag = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 动态绑定的属性</span></span><br><span class="line">    <span class="keyword">let</span> vnodeDynamicProps</span><br><span class="line">    <span class="keyword">let</span> dynamicPropNames</span><br><span class="line">    <span class="keyword">let</span> vnodeDirectives</span><br><span class="line">    <span class="comment">// 动态组件、svg、foreignObject 标签以及动态绑定 key prop 的节点都被视作一个 Block</span></span><br><span class="line">    <span class="keyword">let</span> shouldUseBlock =</span><br><span class="line">      isDynamicComponent ||</span><br><span class="line">      (!isComponent &amp;&amp;</span><br><span class="line">        (tag === <span class="string">&#x27;svg&#x27;</span> ||</span><br><span class="line">          tag === <span class="string">&#x27;foreignObject&#x27;</span> ||</span><br><span class="line">          findProp(node, <span class="string">&#x27;key&#x27;</span>, <span class="literal">true</span>)))</span><br><span class="line">    <span class="comment">// 处理 props</span></span><br><span class="line">    <span class="keyword">if</span> (props.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> propsBuildResult = buildProps(node, context)</span><br><span class="line">      vnodeProps = propsBuildResult.props</span><br><span class="line">      patchFlag = propsBuildResult.patchFlag</span><br><span class="line">      dynamicPropNames = propsBuildResult.dynamicPropNames</span><br><span class="line">      <span class="keyword">const</span> directives = propsBuildResult.directives</span><br><span class="line">      vnodeDirectives =</span><br><span class="line">        directives &amp;&amp; directives.length</span><br><span class="line">          ? createArrayExpression(directives.map(<span class="function"><span class="params">dir</span> =&gt;</span> buildDirectiveArgs(dir, context)))</span><br><span class="line">          : <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 children</span></span><br><span class="line">    <span class="keyword">if</span> (node.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vnodeTag === KEEP_ALIVE) &#123;</span><br><span class="line">        <span class="comment">// 把 KeepAlive 看做是一个 Block，这样可以避免它的子节点的动态节点被父 Block 收集</span></span><br><span class="line">        shouldUseBlock = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 2. 确保它始终更新</span></span><br><span class="line">        patchFlag |= <span class="number">1024</span> <span class="comment">/* DYNAMIC_SLOTS */</span></span><br><span class="line">        <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; node.children.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          context.onError(createCompilerError(<span class="number">42</span> <span class="comment">/* X_KEEP_ALIVE_INVALID_CHILDREN */</span>, &#123;</span><br><span class="line">            start: node.children[<span class="number">0</span>].loc.start,</span><br><span class="line">            end: node.children[node.children.length - <span class="number">1</span>].loc.end,</span><br><span class="line">            source: <span class="string">&#x27;&#x27;</span></span><br><span class="line">          &#125;))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> shouldBuildAsSlots = isComponent &amp;&amp;</span><br><span class="line">        <span class="comment">// Teleport不是一个真正的组件，它有专门的运行时处理</span></span><br><span class="line">        vnodeTag !== TELEPORT &amp;&amp;</span><br><span class="line">        vnodeTag !== KEEP_ALIVE</span><br><span class="line">      <span class="keyword">if</span> (shouldBuildAsSlots) &#123;</span><br><span class="line">        <span class="comment">// 组件有 children，则处理插槽</span></span><br><span class="line">        <span class="keyword">const</span> &#123; slots, hasDynamicSlots &#125; = buildSlots(node, context)</span><br><span class="line">        vnodeChildren = slots</span><br><span class="line">        <span class="keyword">if</span> (hasDynamicSlots) &#123;</span><br><span class="line">          patchFlag |= <span class="number">1024</span> <span class="comment">/* DYNAMIC_SLOTS */</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (node.children.length === <span class="number">1</span> &amp;&amp; vnodeTag !== TELEPORT) &#123;</span><br><span class="line">        <span class="keyword">const</span> child = node.children[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">type</span> = child.type</span><br><span class="line">        <span class="keyword">const</span> hasDynamicTextChild = <span class="keyword">type</span> === <span class="number">5</span> <span class="comment">/* INTERPOLATION */</span> ||</span><br><span class="line">          <span class="keyword">type</span> === <span class="number">8</span> <span class="comment">/* COMPOUND_EXPRESSION */</span></span><br><span class="line">        <span class="keyword">if</span> (hasDynamicTextChild &amp;&amp; !getStaticType(child)) &#123;</span><br><span class="line">          patchFlag |= <span class="number">1</span> <span class="comment">/* TEXT */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果只是一个普通文本节点、插值或者表达式，直接把节点赋值给 vnodeChildren</span></span><br><span class="line">        <span class="keyword">if</span> (hasDynamicTextChild || <span class="keyword">type</span> === <span class="number">2</span> <span class="comment">/* TEXT */</span>) &#123;</span><br><span class="line">          vnodeChildren = child</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeChildren = node.children</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodeChildren = node.children</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 patchFlag 和 dynamicPropNames</span></span><br><span class="line">    <span class="keyword">if</span> (patchFlag !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (patchFlag &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          vnodePatchFlag = patchFlag + <span class="string">` /* <span class="subst">$&#123;PatchFlagNames[patchFlag]&#125;</span> */`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 获取 flag 对应的名字，生成注释，方便理解生成代码对应节点的 pathFlag</span></span><br><span class="line">          <span class="keyword">const</span> flagNames = <span class="built_in">Object</span>.keys(PatchFlagNames)</span><br><span class="line">            .map(<span class="built_in">Number</span>)</span><br><span class="line">            .filter(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">0</span> &amp;&amp; patchFlag &amp; n)</span><br><span class="line">            .map(<span class="function"><span class="params">n</span> =&gt;</span> PatchFlagNames[n])</span><br><span class="line">            .join(<span class="string">`, `</span>)</span><br><span class="line">          vnodePatchFlag = patchFlag + <span class="string">` /* <span class="subst">$&#123;flagNames&#125;</span> */`</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodePatchFlag = <span class="built_in">String</span>(patchFlag)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dynamicPropNames &amp;&amp; dynamicPropNames.length) &#123;</span><br><span class="line">        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, <span class="literal">false</span> <span class="comment">/* disableTracking */</span>, node.loc)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，只有当 AST 节点是组件或者普通元素节点时，才会返回一个退出函数，而且它会在该节点的子节点逻辑处理完毕后执行。</p>
<p>分析这个退出函数前，我们需要知道节点函数的转换目标，即创建一个实现 VNodeCall 接口的代码生成节点，也就是说，生成这个代码生成节点后，后续的代码生成阶段可以根据这个节点对象生成目标代码。</p>
<p>知道了这个目标，我们再去理解 transformElement 函数的实现就不难了。</p>
<ul>
<li>首先，<strong>判断这个节点是不是一个 Block 节点</strong>。</li>
</ul>
<p>为了运行时的更新优化，Vue.js 3.0 设计了一个 Block tree 的概念。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，极大优化了 diff 的效率，模板的动静比越大，这个优化就会越明显。</p>
<p>因此在编译阶段，我们需要找出哪些节点可以构成一个 Block，其中动态组件、svg、foreignObject 标签以及动态绑定的 prop 的节点都被视作一个 Block。</p>
<ul>
<li>其次，<strong>是处理节点的 props</strong>。</li>
</ul>
<p>这个过程主要是从 AST 节点的 props 对象中进一步解析出指令 vnodeDirectives、动态属性 dynamicPropNames，以及更新标识 patchFlag。patchFlag 主要用于标识节点更新的类型，在组件更新的优化中会用到，我们在后续章节会详细讲。</p>
<ul>
<li>接着，<strong>是处理节点的 children</strong></li>
</ul>
<p>对于一个组件节点而言，如果它有子节点，则说明是组件的插槽，另外还会有对一些内置组件比如 KeepAlive、Teleport 的处理逻辑。</p>
<p>对于一个普通元素节点，我们通常直接拿节点的 children 属性给 vnodeChildren 即可，但有一种特殊情况，<strong>如果节点只有一个子节点，并且是一个普通文本节点、插值或者表达式，那么直接把节点赋值给 vnodeChildren</strong>。</p>
<ul>
<li>然后，<strong>会对前面解析 props 求得的 patchFlag 和 dynamicPropNames 做进一步处理</strong>。</li>
</ul>
<p>在这个过程中，我们会根据 patchFlag 的值从 PatchFlagNames 中获取 flag 对应的名字，从而生成注释，因为 patchFlag 本身就是一个个数字，通过名字注释的方式，我们就可以一眼从最终生成的代码中了解到 patchFlag 代表的含义。</p>
<p>另外，我们还会把数组 dynamicPropNames 转化生成 vnodeDynamicProps 字符串，便于后续对节点生成代码逻辑的处理。</p>
<ul>
<li>最后，<strong>通过 createVNodeCall 创建了实现 VNodeCall 接口的代码生成节点</strong>，我们来看它的实现：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createVNodeCall</span>(<span class="params">context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = <span class="literal">false</span>, disableTracking = <span class="literal">false</span>, loc = locStub</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlock) &#123;</span><br><span class="line">      context.helper(OPEN_BLOCK)</span><br><span class="line">      context.helper(CREATE_BLOCK)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      context.helper(CREATE_VNODE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (directives) &#123;</span><br><span class="line">      context.helper(WITH_DIRECTIVES) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="number">13</span> <span class="comment">/* VNODE_CALL */</span>,</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dynamicProps,</span><br><span class="line">    directives,</span><br><span class="line">    isBlock,</span><br><span class="line">    disableTracking,</span><br><span class="line">    loc</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createVNodeCall 的实现很简单，它最后返回了一个对象，包含了传入的参数数据。这里要注意 context.helper 函数的调用，它会把一些 Symbol 对象添加到 context.helpers 数组中，目的是为了后续代码生成阶段，生成一些辅助代码。</p>
<p>对于我们示例中的根节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>它转换后生成的 node.codegenNode ：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;directives&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="string">&quot;dynamicProps&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="string">&quot;isBlock&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;isForBlock&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;patchFlag&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="string">&quot;props&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 属性相关</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="number">13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 codegenNode 相比之前的 AST 节点对象，多了很多和编译优化相关的属性，它们会在代码生成阶段会起到非常重要作用，在后续的章节你就可以深入了解到。</p>
<h4 id="表达式节点转换函数">表达式节点转换函数</h4>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transformExpression = <span class="function">(<span class="params">node, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">5</span> <span class="comment">/* INTERPOLATION */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理插值中的动态表达式</span></span><br><span class="line">    node.content = processExpression(node.content, context)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (node.type === <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理元素指令中的动态表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.props.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> dir = node.props[i]</span><br><span class="line">      <span class="comment">// v-on 和 v-for 不处理，因为它们都有各自的处理逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (dir.type === <span class="number">7</span> <span class="comment">/* DIRECTIVE */</span> &amp;&amp; dir.name !== <span class="string">&#x27;for&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> exp = dir.exp</span><br><span class="line">        <span class="keyword">const</span> arg = dir.arg</span><br><span class="line">        <span class="keyword">if</span> (exp &amp;&amp;</span><br><span class="line">          exp.type === <span class="number">4</span> <span class="comment">/* SIMPLE_EXPRESSION */</span> &amp;&amp;</span><br><span class="line">          !(dir.name === <span class="string">&#x27;on&#x27;</span> &amp;&amp; arg)) &#123;</span><br><span class="line">          dir.exp = processExpression(exp, context, dir.name === <span class="string">&#x27;slot&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arg &amp;&amp; arg.type === <span class="number">4</span> <span class="comment">/* SIMPLE_EXPRESSION */</span> &amp;&amp; !arg.isStatic) &#123;</span><br><span class="line">          dir.arg = processExpression(arg, context)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于表达式本身不会再有子节点，所以它也不需要退出函数，直接在进入函数时做转换处理即可。</p>
<p>需要注意的是，<strong>只有在 Node.js 环境下的编译或者是 Web 端的非生产环境下才会执行 transformExpression</strong>，原因我稍后会告诉你。</p>
<p>transformExpression 主要做的事情就是转换插值和元素指令中的动态表达式，把简单的表达式对象转换成复合表达式对象，内部主要是通过 processExpression 函数完成。举个例子，比如这个模板：NaN，它执行 parse 后生成的表达式节点 node.content 值为一个简单的表达式对象：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;msg + test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过 processExpression 处理后，node.content 的值变成了一个复合表达式对象：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="number">8</span>,</span><br><span class="line">  <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.msg&quot;</span>,</span><br><span class="line">      <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot; + &quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.test&quot;</span>,</span><br><span class="line">      <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;identifiers&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们重点关注对象中的 children 属性，它是一个长度为 3 的数组，其实就是把表达式msg + test拆成了三部分，其中变量 msg 和 test 对应都加上了前缀 _ctx。</p>
<p>那么为什么需要加这个前缀呢？</p>
<p>我们就要想到模板中引用的的 msg 和 test 对象最终都是在组件实例中访问的，但为了书写模板方便，Vue.js 并没有让我们在模板中手动加组件实例的前缀，例如：<code>&#123;&#123; this.msg + this.test &#125;&#125;</code>，这样写起来就会不够方便，但如果用 JSX 写的话，通常要手动写 this。</p>
<p>你可能会有疑问，为什么 Vue.js 2.x 编译的结果没有 _ctx 前缀呢？这是因为 Vue.js 2.x 的编译结果使用了”黑魔法“ with，比如上述模板，在 Vue.js 2.x 最终编译的结果：<code>with(this)&#123;return _s(msg + test)&#125;</code>。with 语句的运行时性能不够好所以被弃用了。</p>
<p>它利用 with 的特性动态去 this 中查找 msg 和 test 属性，所以不需要手动加前缀。</p>
<p>但是，Vue.js 3.0 在 Node.js 端的编译结果舍弃了 with，它会在 processExpression 过程中对表达式动态分析，给该加前缀的地方加上前缀。</p>
<p>processExpression 的详细实现我们不会分析，但你需要知道，这个过程肯定有一定的成本，因为它内部依赖了 @babel/parser 库去解析表达式生成 AST 节点，并依赖了 estree-walker 库去遍历这个 AST 节点，然后对节点分析去判断是否需要加前缀，接着对 AST 节点修改，最终转换生成新的表达式对象。</p>
<p>@babel/parser 这个库通常是在 Node.js 端用的，而且这库本身体积非常大，如果打包进 Vue.js 的话会让包体积膨胀 4 倍，所以我们并不会在生产环境的 Web 端引入这个库，Web 端生产环境下的运行时编译最终仍然会用 with 的方式。</p>
<p>因为用 with 的话就完全不需要对表达式做转换了，这也就回答我前面的问题：<strong>只有在 Node.js 环境下的编译或者是 Web 端的非生产环境下才会执行 transformExpression</strong>。</p>
<h4 id="Text-节点转换函数">Text 节点转换函数</h4>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transformText = <span class="function">(<span class="params">node, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">0</span> <span class="comment">/* ROOT */</span> ||</span><br><span class="line">    node.type === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> ||</span><br><span class="line">    node.type === <span class="number">11</span> <span class="comment">/* FOR */</span> ||</span><br><span class="line">    node.type === <span class="number">10</span> <span class="comment">/* IF_BRANCH */</span>) &#123;</span><br><span class="line">    <span class="comment">// 在节点退出时执行转换，保证所有表达式都已经被处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> children = node.children</span><br><span class="line">      <span class="keyword">let</span> currentContainer = <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">let</span> hasText = <span class="literal">false</span></span><br><span class="line">      <span class="comment">// 将相邻文本节点合并</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> child = children[i]</span><br><span class="line">        <span class="keyword">if</span> (isText(child)) &#123;</span><br><span class="line">          hasText = <span class="literal">true</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; children.length; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> next = children[j]</span><br><span class="line">            <span class="keyword">if</span> (isText(next)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!currentContainer) &#123;</span><br><span class="line">                <span class="comment">// 创建复合表达式节点</span></span><br><span class="line">                currentContainer = children[i] = &#123;</span><br><span class="line">                  <span class="keyword">type</span>: <span class="number">8</span> <span class="comment">/* COMPOUND_EXPRESSION */</span>,</span><br><span class="line">                  loc: child.loc,</span><br><span class="line">                  children: [child]</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              currentContainer.children.push(<span class="string">` + `</span>, next)</span><br><span class="line">              children.splice(j, <span class="number">1</span>)</span><br><span class="line">              j--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              currentContainer = <span class="literal">undefined</span></span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!hasText ||</span><br><span class="line">        <span class="comment">// 如果是一个带有单个文本子元素的纯元素节点，什么都不需要转换，因为这种情况在运行时可以直接设置元素的 textContent 来更新文本。</span></span><br><span class="line">        (children.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">          (node.type === <span class="number">0</span> <span class="comment">/* ROOT */</span> ||</span><br><span class="line">            (node.type === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> &amp;&amp;</span><br><span class="line">              node.tagType === <span class="number">0</span> <span class="comment">/* ELEMENT */</span>)))) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为子文本节点创建一个调用函数表达式的代码生成节点</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> child = children[i]</span><br><span class="line">        <span class="keyword">if</span> (isText(child) || child.type === <span class="number">8</span> <span class="comment">/* COMPOUND_EXPRESSION */</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> callArgs = []</span><br><span class="line">          <span class="comment">// 为 createTextVNode 添加执行参数</span></span><br><span class="line">          <span class="keyword">if</span> (child.type !== <span class="number">2</span> <span class="comment">/* TEXT */</span> || child.content !== <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            callArgs.push(child)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 标记动态文本</span></span><br><span class="line">          <span class="keyword">if</span> (!context.ssr &amp;&amp; child.type !== <span class="number">2</span> <span class="comment">/* TEXT */</span>) &#123;</span><br><span class="line">            callArgs.push(<span class="string">`<span class="subst">$&#123;<span class="number">1</span> <span class="regexp">/* TEXT */</span>&#125;</span> /* <span class="subst">$&#123;PatchFlagNames[<span class="number">1</span> <span class="regexp">/* TEXT */</span>]&#125;</span> */`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          children[i] = &#123;</span><br><span class="line">            <span class="keyword">type</span>: <span class="number">12</span> <span class="comment">/* TEXT_CALL */</span>,</span><br><span class="line">            content: child,</span><br><span class="line">            loc: child.loc,</span><br><span class="line">            codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transformText 函数只处理根节点、元素节点、 v-for 以及 v-if 分支相关的节点，它也会返回一个退出函数，因为 transformText 要保证所有表达式节点都已经被处理才执行转换逻辑。</p>
<p>transformText 主要的目的就是合并一些相邻的文本节点，然后为内部每一个文本节点创建一个代码生成节点。</p>
<p>在内部，静态文本节点和动态插值节点都被看作是一个文本节点，所以函数首先遍历节点的子节点，然后把子节点中的相邻文本节点合并成一个。</p>
<p>比如示例中的文本节点：<code>&lt;p&gt;hello &#123;&#123; msg + test &#125;&#125;&lt;/p&gt;</code>。</p>
<p>在转换之前，p 节点对应的 children 数组有两个元素，第一个是纯文本节点，第二个是一个插值节点，转换后，这两个文本节点被合并成一个复合表达式节点，结果如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;hello &quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot; + &quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="number">8</span>,</span><br><span class="line">          <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">              <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.msg&quot;</span>,</span><br><span class="line">              <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot; + &quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">              <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.test&quot;</span>,</span><br><span class="line">              <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="string">&quot;identifiers&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>合并完子文本节点后，接着判断如果是一个只带有单个文本子元素的纯元素节点，则什么都不需要转换，因为这种情况在运行时可以直接设置元素的 textContent 来更新文本。</p>
<p>最后就是去处理节点包含文本子节点且多个子节点的情况，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  hello &#123;&#123; msg + test &#125;&#125;</span><br><span class="line">  &lt;a href&#x3D;&quot;foo&quot;&#x2F;&gt;</span><br><span class="line">  hi</span><br><span class="line">&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p>上述 p 标签的子节点经过前面的文本合并流程后，还有 3 个子节点。针对这种情况，我们可以遍历子节点，找到所有的文本节点或者是复合表达式节点，然后为这些子节点通过 createCallExpression 创建一个调用函数表达式的代码生成节点。</p>
<p>我们来看 createCallExpression 的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCallExpression</span>(<span class="params">callee, args = [], loc = locStub</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="number">14</span> <span class="comment">/* JS_CALL_EXPRESSION */</span>,</span><br><span class="line">    loc,</span><br><span class="line">    callee,</span><br><span class="line">    <span class="built_in">arguments</span>: args</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createCallExpression 的实现很简单，就是返回一个类型为 JS_CALL_EXPRESSION 的对象，它包含了执行的函数名和参数。</p>
<p>这里，针对我们创建的函数表达式所生成的节点，它对应的函数名是 createTextVNode，参数 callArgs 是子节点本身 child，如果是动态插值节点，那么参数还会多一个 TEXT 的 patchFlag。</p>
<h4 id="v-if-节点转换函数">v-if 节点转换函数</h4>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transformIf = createStructuralDirectiveTransform(<span class="regexp">/^(if|else|else-if)$/</span>, <span class="function">(<span class="params">node, dir, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> processIf(node, dir, context, <span class="function">(<span class="params">ifNode, branch, isRoot</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 退出回调函数，当所有子节点转换完成执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在分析函数的实现前，我们先来看一下 v-if 节点转换的目的，为了方便你的理解，我还是通过示例来说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;hello v-if&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;hello&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  &lt;p&gt;hello &#123;&#123; msg + test &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;static&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;static&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>在 parse 阶段，这个模板解析生成的 AST 节点如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;children&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;codegenNode&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">&quot;isSelfClosing&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;ns&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;props&quot;</span>: [&#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="number">7</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;if&quot;</span>,</span><br><span class="line">      <span class="string">&quot;exp&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;flag&quot;</span>,</span><br><span class="line">        <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;arg&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;modifiers&quot;</span>: []</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tagType&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">      <span class="comment">// 子节点</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;codegenNode&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">&quot;isSelfClosing&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;ns&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;props&quot;</span>: [&#123; </span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="number">7</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;else&quot;</span>,</span><br><span class="line">      <span class="string">&quot;exp&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;arg&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;modifiers&quot;</span>: []</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tagType&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>v-if 指令用于条件性地渲染一块内容，显然上述 AST 节点对于最终去生成条件的代码而言，是不够语义化的，于是我们需要对它们做一层转换，使其成为语义化强的代码生成节点。</p>
<p>现在我们回过头看 transformIf 的实现，它是通过 createStructuralDirectiveTransform 函数创建的一个结构化指令的转换函数，在 Vue.js 中，v-if、v-else-if、v-else 和 v-for 这些都属于结构化指令，因为它们能影响代码的组织结构。</p>
<p>我们来看一下 createStructuralDirectiveTransform 的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStructuralDirectiveTransform</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="built_in">string</span> | <span class="built_in">RegExp</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  fn: StructuralDirectiveTransform</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">NodeTransform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> matches = isString(name)</span><br><span class="line">    ? <span class="function">(<span class="params">n: <span class="built_in">string</span></span>) =&gt;</span> n === name</span><br><span class="line">    : <span class="function">(<span class="params">n: <span class="built_in">string</span></span>) =&gt;</span> name.test(n)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">node, context</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只处理元素节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.type === NodeTypes.ELEMENT) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; props &#125; = node</span><br><span class="line">      <span class="comment">// 结构化指令的转换与插槽无关，插槽相关处理逻辑在 vSlot.ts 中</span></span><br><span class="line">      <span class="keyword">if</span> (node.tagType === ElementTypes.TEMPLATE &amp;&amp; props.some(isVSlot)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> exitFns = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> prop = props[i]</span><br><span class="line">        <span class="keyword">if</span> (prop.type === NodeTypes.DIRECTIVE &amp;&amp; matches(prop.name)) &#123;</span><br><span class="line">          <span class="comment">// 删除结构指令以避免无限递归</span></span><br><span class="line">          <span class="comment">// also we remove them *before* applying so that it can further</span></span><br><span class="line">          <span class="comment">// traverse itself in case it moves the node around</span></span><br><span class="line">          props.splice(i, <span class="number">1</span>)</span><br><span class="line">          i--</span><br><span class="line">          <span class="keyword">const</span> onExit = fn(node, prop, context)</span><br><span class="line">          <span class="keyword">if</span> (onExit) exitFns.push(onExit)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> exitFns</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，createStructuralDirectiveTransform 接受 2 个参数，第一个 name 是指令的名称，第二个 fn 是构造转换退出函数的方法。</p>
<p>createStructuralDirectiveTransform 最后会返回一个函数，在我们的场景下，这个函数就是 transformIf 转换函数。</p>
<p>我们进一步看这个函数的实现，它只处理元素节点，这个很好理解，因为只有元素节点才会有 v-if 指令，接着会解析这个节点的 props 属性，如果发现 props 包含 if 属性，也就是节点拥有 v-if 指令，那么先从 props 删除这个结构化指令防止无限递归，然后执行 fn 获取对应的退出函数，最后将这个退出函数返回。</p>
<p>接着我们来看 fn 的实现，在我们这个场景下 fn 对应的是前面传入的匿名函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(node, dir, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> processIf(node, dir, context, <span class="function">(<span class="params">ifNode, branch, isRoot</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 退出回调函数，当所有子节点转换完成执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这个匿名函数内部执行了 processIf 函数，它会先对 v-if 和它的相邻节点做转换，然后返回一个退出函数，在它们的子节点都转换完毕后执行。</p>
<p>我们来看 processIf 函数的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processIf</span>(<span class="params">node, dir, context, processCodegen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dir.name === <span class="string">&#x27;if&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建分支节点</span></span><br><span class="line">    <span class="keyword">const</span> branch = createIfBranch(node, dir)</span><br><span class="line">    <span class="comment">// 创建 IF 节点，替换当前节点</span></span><br><span class="line">    <span class="keyword">const</span> ifNode = &#123;</span><br><span class="line">      <span class="keyword">type</span>: <span class="number">9</span> <span class="comment">/* IF */</span>,</span><br><span class="line">      loc: node.loc,</span><br><span class="line">      branches: [branch]</span><br><span class="line">    &#125;</span><br><span class="line">    context.replaceNode(ifNode)</span><br><span class="line">    <span class="keyword">if</span> (processCodegen) &#123;</span><br><span class="line">      <span class="keyword">return</span> processCodegen(ifNode, branch, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 v-if 相邻节点，比如 v-else-if 和 v-else</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processIf 主要就是用来处理 v-if 节点以及 v-if 的相邻节点，比如 v-else-if 和 v-else，并且它们会走不同的处理逻辑。</p>
<p>我们先来看 v-if 的处理逻辑。首先，它会执行 createIfBranch 去创建一个分支节点：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIfBranch</span>(<span class="params">node, dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="number">10</span> <span class="comment">/* IF_BRANCH */</span>,</span><br><span class="line">    loc: node.loc,</span><br><span class="line">    condition: dir.name === <span class="string">&#x27;else&#x27;</span> ? <span class="literal">undefined</span> : dir.exp,</span><br><span class="line">    children: node.tagType === <span class="number">3</span> <span class="comment">/* TEMPLATE */</span> ? node.children : [node]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的子节点也都可以属于一个分支，而最终页面渲染执行哪个分支，这取决于哪个分支节点的 condition 为 true。</p>
<p>所以分支节点返回的对象，就包含了 condition 条件，以及它的子节点 children。注意，<strong>如果节点 node 不是 template，那么 children 指向的就是这个单个 node 构造的数组</strong>。</p>
<p>接下来它会创建 IF 节点替换当前节点，IF 节点拥有 branches 属性，包含我们前面创建的分支节点，显然，相对于原节点，IF 节点的语义化更强，更利于后续生成条件表达式代码。</p>
<p>最后它会执行 processCodegen 创建退出函数。我们先不着急去分析退出函数的创建过程，先把 v-if 相邻节点的处理逻辑分析完：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processIf</span>(<span class="params">node, dir, context, processCodegen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dir.name === <span class="string">&#x27;if&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 v-if 节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 v-if 相邻节点，比如 v-else-if 和 v-else</span></span><br><span class="line">    <span class="keyword">const</span> siblings = context.parent.children</span><br><span class="line">    <span class="keyword">let</span> i = siblings.indexOf(node)</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt;= -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> sibling = siblings[i]</span><br><span class="line">      <span class="keyword">if</span> (sibling &amp;&amp; sibling.type === <span class="number">9</span> <span class="comment">/* IF */</span>) &#123;</span><br><span class="line">        <span class="comment">// 把节点移动到 IF 节点的 branches 中</span></span><br><span class="line">        context.removeNode()</span><br><span class="line">        <span class="keyword">const</span> branch = createIfBranch(node, dir)</span><br><span class="line">        sibling.branches.push(branch)</span><br><span class="line">        <span class="keyword">const</span> onExit = processCodegen &amp;&amp; processCodegen(sibling, branch, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 因为分支已被删除，所以它的子节点需要在这里遍历</span></span><br><span class="line">        traverseNode(branch, context)</span><br><span class="line">        <span class="comment">// 执行退出函数</span></span><br><span class="line">        <span class="keyword">if</span> (onExit)</span><br><span class="line">          onExit()</span><br><span class="line">        <span class="comment">// 恢复 currentNode 为 null，因为它已经被移除</span></span><br><span class="line">        context.currentNode = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        context.onError(createCompilerError(<span class="number">28</span> <span class="comment">/* X_V_ELSE_NO_ADJACENT_IF */</span>, node.loc))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段处理逻辑就是从当前节点往前面的兄弟节点遍历，找到 v-if 节点后，把当前节点删除，然后根据当前节点创建一个分支节点，把这个分支节点添加到前面创建的 IF 节点的 branches 中。此外，由于这个节点已经删除，那么需要在这里把这个节点的子节点通过 traverseNode 遍历一遍。</p>
<p>这么处理下来，就相当于完善了 IF 节点的信息了，IF 节点的 branches 就包含了所有分支节点了。</p>
<p>那么至此，进入 v-if、v-else-if、v-else 这些节点的转换逻辑我们就分析完毕了，即最终创建了一个 IF 节点，它包含了所有的分支节点。</p>
<p>接下来，我们再来分析这个退出函数的逻辑：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(node, dir, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> processIf(node, dir, context, <span class="function">(<span class="params">ifNode, branch, isRoot</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 退出回调函数，当所有子节点转换完成执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRoot) &#123;</span><br><span class="line">        <span class="comment">// v-if 节点的退出函数</span></span><br><span class="line">        <span class="comment">// 创建 IF 节点的 codegenNode</span></span><br><span class="line">        ifNode.codegenNode = createCodegenNodeForBranch(branch, <span class="number">0</span>, context)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// v-else-if、v-else 节点的退出函数</span></span><br><span class="line">        <span class="comment">// 将此分支的 codegenNode 附加到 上一个条件节点的 codegenNode 的 alternate 中</span></span><br><span class="line">        <span class="keyword">let</span> parentCondition = ifNode.codegenNode</span><br><span class="line">        <span class="keyword">while</span> (parentCondition.alternate.type ===</span><br><span class="line">        <span class="number">19</span> <span class="comment">/* JS_CONDITIONAL_EXPRESSION */</span>) &#123;</span><br><span class="line">          parentCondition = parentCondition.alternate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新候选节点</span></span><br><span class="line">        parentCondition.alternate = createCodegenNodeForBranch(branch, ifNode.branches.length - <span class="number">1</span>, context)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当 v-if 节点执行退出函数时，会通过 createCodegenNodeForBranch 创建 IF 分支节点的 codegenNode，我们来看一下它的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCodegenNodeForBranch</span>(<span class="params">branch, index, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (branch.condition) &#123;</span><br><span class="line">    <span class="keyword">return</span> createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, index, context),</span><br><span class="line">      createCallExpression(context.helper(CREATE_COMMENT), [</span><br><span class="line">        (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) ? <span class="string">&#x27;&quot;v-if&quot;&#x27;</span> : <span class="string">&#x27;&quot;&quot;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      ]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createChildrenCodegenNode(branch, index, context)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当分支节点存在 condition 的时候，比如 v-if、和 v-else-if，它通过 createConditionalExpression 返回一个条件表达式节点：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createConditionalExpression</span>(<span class="params">test, consequent, alternate, newline = <span class="literal">true</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="number">19</span> <span class="comment">/* JS_CONDITIONAL_EXPRESSION */</span>,</span><br><span class="line">    test,</span><br><span class="line">    consequent,</span><br><span class="line">    alternate,</span><br><span class="line">    newline,</span><br><span class="line">    loc: locStub</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 consequent 在这里是 IF 主 branch 的子节点对应的代码生成节点，alternate 是后补 branch 子节点对应的代码生成节点。</p>
<p>接着，我们来看一下 createChildrenCodegenNode 的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChildrenCodegenNode</span>(<span class="params">branch, index, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; helper &#125; = context</span><br><span class="line">  <span class="comment">// 根据 index 创建 key 属性</span></span><br><span class="line">  <span class="keyword">const</span> keyProperty = createObjectProperty(<span class="string">`key`</span>, createSimpleExpression(index + <span class="string">&#x27;&#x27;</span>, <span class="literal">false</span>))</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = branch</span><br><span class="line">  <span class="keyword">const</span> firstChild = children[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> needFragmentWrapper = children.length !== <span class="number">1</span> || firstChild.type !== <span class="number">1</span> <span class="comment">/* ELEMENT */</span></span><br><span class="line">  <span class="keyword">if</span> (needFragmentWrapper) &#123;</span><br><span class="line">    <span class="keyword">if</span> (children.length === <span class="number">1</span> &amp;&amp; firstChild.type === <span class="number">11</span> <span class="comment">/* FOR */</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> vnodeCall = firstChild.codegenNode</span><br><span class="line">      injectProp(vnodeCall, keyProperty, context)</span><br><span class="line">      <span class="keyword">return</span> vnodeCall</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, <span class="string">`<span class="subst">$&#123;<span class="number">64</span> <span class="regexp">/* STABLE_FRAGMENT */</span>&#125;</span> /* <span class="subst">$&#123;PatchFlagNames[<span class="number">64</span> <span class="regexp">/* STABLE_FRAGMENT */</span>]&#125;</span> */`</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">true</span>, <span class="literal">false</span>, branch.loc)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vnodeCall = firstChild</span><br><span class="line">      .codegenNode;</span><br><span class="line">    <span class="comment">// 把 createVNode 改变为 createBlock</span></span><br><span class="line">    <span class="keyword">if</span> (vnodeCall.type === <span class="number">13</span> <span class="comment">/* VNODE_CALL */</span> &amp;&amp;</span><br><span class="line">      <span class="comment">// 组件节点的 children 会被视为插槽，不需要添加 block</span></span><br><span class="line">      (firstChild.tagType !== <span class="number">1</span> <span class="comment">/* COMPONENT */</span> ||</span><br><span class="line">        vnodeCall.tag === TELEPORT)) &#123;</span><br><span class="line">      vnodeCall.isBlock = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 创建 block 的辅助代码</span></span><br><span class="line">      helper(OPEN_BLOCK)</span><br><span class="line">      helper(CREATE_BLOCK)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 branch 注入 key 属性</span></span><br><span class="line">    injectProp(vnodeCall, keyProperty, context)</span><br><span class="line">    <span class="keyword">return</span> vnodeCall</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createChildrenCodegenNode 主要就是判断每个分支子节点是不是一个 vnodeCall，如果这个子节点不是组件节点的话，则把它转变成一个 BlockCall，也就是让 v-if 的每一个分支都可以创建一个 Block。</p>
<p>这个行为是很好理解的，因为 v-if 是条件渲染的，我们知道在某些条件下某些分支是不会渲染的，那么它内部的动态节点就不能添加到外部的 Block 中的，所以它就需要单独创建一个 Block 来维护分支内部的动态节点，这样也就构成了 Block tree。</p>
<p>为了直观让你感受 v-if 节点最终转换的结果，我们来看前面示例转换后的结果，最终转换生成的 IF 节点对象大致如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="number">9</span>,</span><br><span class="line">  <span class="string">&quot;branches&quot;</span>: [&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>: <span class="number">10</span>,</span><br><span class="line">     <span class="string">&quot;children&quot;</span>: [&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;tagType&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line">     &#125;],</span><br><span class="line">     <span class="string">&quot;condition&quot;</span>: &#123;</span><br><span class="line">       <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">       <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.flag&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>: <span class="number">10</span>,</span><br><span class="line">     <span class="string">&quot;children&quot;</span>: [&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;tagType&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line">     &#125;],</span><br><span class="line">     <span class="string">&quot;condition&quot;</span>: &#123;</span><br><span class="line">       <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">       <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.flag&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">&quot;codegenNode&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="string">&quot;consequent&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="number">13</span>,</span><br><span class="line">      <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;_component_hello&quot;</span>,</span><br><span class="line">      <span class="string">&quot;children&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;directives&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;dynamicProps&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;isBlock&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;patchFlag&quot;</span>: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;alternate&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="number">13</span>,</span><br><span class="line">      <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;_component_hello&quot;</span>,</span><br><span class="line">      <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">        <span class="comment">// 子节点</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;directives&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;dynamicProps&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;isBlock&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;patchFlag&quot;</span>: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，相比原节点，转换后的 IF 节点无论是在语义化还是在信息上，都更加丰富，我们可以依据它在代码生成阶段生成所需的代码。</p>
<h3 id="静态提升">静态提升</h3>
<p>节点转换完毕后，接下来会判断编译配置中是否配置了 hoistStatic，如果是就会执行 hoistStatic 做静态提升：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.hoistStatic) &#123;</span><br><span class="line">  hoistStatic(root, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态提升也是 Vue.js 3.0 在编译阶段设计了一个优化策略，为了便于你理解，我先举个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&gt;hello &#123;&#123; msg + test &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;static&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;static&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p>我们为它配置了 hoistStatic，经过编译后，它的代码就变成了这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toDisplayString <span class="keyword">as</span> _toDisplayString, createVNode <span class="keyword">as</span> _createVNode, Fragment <span class="keyword">as</span> _Fragment, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span>_createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;static&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span>_createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;static&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;hello &quot;</span> + _toDisplayString(_ctx.msg + _ctx.test), <span class="number">1</span> <span class="comment">/* TEXT */</span>),</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    _hoisted_2</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们先忽略 openBlock、Fragment ，我会在代码生成章节详细说明，重点看一下 _hoisted_1 和 _hoisted_2 这两个变量，它们分别对应模板中两个静态 p 标签生成的 vnode，可以发现它的创建是在 render 函数外部执行的。</p>
<p>这样做的好处是，不用每次在 render 阶段都执行一次 createVNode 创建 vnode 对象，直接用之前在内存中创建好的 vnode 即可。</p>
<p>那么为什么叫静态提升呢？</p>
<p><strong>因为这些静态节点不依赖动态数据，一旦创建了就不会改变，所以只有静态节点才能被提升到外部创建</strong>。</p>
<p>了解以上背景知识后，我们接下来看一下静态提升的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistStatic</span>(<span class="params">root, context</span>) </span>&#123;</span><br><span class="line">  walk(root, context, <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">    <span class="comment">// Root node is unfortunately non-hoistable due to potential parent fallthrough attributes.</span></span><br><span class="line">    isSingleElementRoot(root, root.children[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">node, context, resultCache, doNotHoistNode = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hasHoistedNode = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 是否包含运行时常量</span></span><br><span class="line">  <span class="keyword">let</span> hasRuntimeConstant = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = node</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = children[i]</span><br><span class="line">    <span class="comment">// 只有普通元素和文本节点才能被静态提升</span></span><br><span class="line">    <span class="keyword">if</span> (child.type === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> &amp;&amp;</span><br><span class="line">      child.tagType === <span class="number">0</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> staticType</span><br><span class="line">      <span class="keyword">if</span> (!doNotHoistNode &amp;&amp;</span><br><span class="line">        <span class="comment">// 获取静态节点的类型，如果是元素，则递归检查它的子节点</span></span><br><span class="line">        (staticType = getStaticType(child, resultCache)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (staticType === <span class="number">2</span> <span class="comment">/* HAS_RUNTIME_CONSTANT */</span>) &#123;</span><br><span class="line">          hasRuntimeConstant = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 patchFlag</span></span><br><span class="line">        child.codegenNode.patchFlag =</span><br><span class="line">          -<span class="number">1</span> <span class="comment">/* HOISTED */</span> + ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) ? <span class="string">` /* HOISTED */`</span> : <span class="string">``</span>)</span><br><span class="line">        <span class="comment">// 更新节点的 codegenNode</span></span><br><span class="line">        child.codegenNode = context.hoist(child.codegenNode)</span><br><span class="line">        hasHoistedNode = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点可能会包含一些动态子节点，但它的静态属性还是可以被静态提升</span></span><br><span class="line">        <span class="keyword">const</span> codegenNode = child.codegenNode</span><br><span class="line">        <span class="keyword">if</span> (codegenNode.type === <span class="number">13</span> <span class="comment">/* VNODE_CALL */</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> flag = getPatchFlag(codegenNode)</span><br><span class="line">          <span class="keyword">if</span> ((!flag ||</span><br><span class="line">            flag === <span class="number">512</span> <span class="comment">/* NEED_PATCH */</span> ||</span><br><span class="line">            flag === <span class="number">1</span> <span class="comment">/* TEXT */</span>) &amp;&amp;</span><br><span class="line">            !hasDynamicKeyOrRef(child) &amp;&amp;</span><br><span class="line">            !hasCachedProps()) &#123;</span><br><span class="line">            <span class="keyword">const</span> props = getNodeProps(child)</span><br><span class="line">            <span class="keyword">if</span> (props) &#123;</span><br><span class="line">              codegenNode.props = context.hoist(props)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child.type === <span class="number">12</span> <span class="comment">/* TEXT_CALL */</span>) &#123;</span><br><span class="line">      <span class="comment">// 文本节点也可以静态提升</span></span><br><span class="line">      <span class="keyword">const</span> staticType = getStaticType(child.content, resultCache)</span><br><span class="line">      <span class="keyword">if</span> (staticType &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (staticType === <span class="number">2</span> <span class="comment">/* HAS_RUNTIME_CONSTANT */</span>) &#123;</span><br><span class="line">          hasRuntimeConstant = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        child.codegenNode = context.hoist(child.codegenNode)</span><br><span class="line">        hasHoistedNode = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.type === <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归遍历子节点</span></span><br><span class="line">      walk(child, context, resultCache)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child.type === <span class="number">11</span> <span class="comment">/* FOR */</span>) &#123;</span><br><span class="line">      walk(child, context, resultCache, child.children.length === <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child.type === <span class="number">9</span> <span class="comment">/* IF */</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; child.branches.length; i++) &#123;</span><br><span class="line">        walk(child.branches[i], context, resultCache, child.branches[i].children.length === <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!hasRuntimeConstant &amp;&amp; hasHoistedNode &amp;&amp; context.transformHoist) &#123;</span><br><span class="line">    <span class="comment">// 如果编译配置了 transformHoist，则执行</span></span><br><span class="line">    context.transformHoist(children, context, node)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<strong>hoistStatic 主要就是从根节点开始，通过递归的方式去遍历节点，只有普通元素和文本节点才能被静态提升，所以针对这些节点，这里通过 getStaticType 去获取静态类型，如果节点是一个元素类型，getStaticType 内部还会递归判断它的子节点的静态类型</strong>。</p>
<p>虽然有的节点包含一些动态子节点，但它本身的静态属性还是可以被静态提升的。</p>
<p>注意，<strong>如果 getStaticType 返回的 staticType 的值是 2，则表明它是一个运行时常量，由于它的值在运行时才能被确定，所以是不能静态提升的</strong>。</p>
<p>如果节点满足可以被静态提升的条件，节点对应的 codegenNode 会通过执行 context.hoist 修改为一个简单表达式节点：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoist</span>(<span class="params">exp</span>) </span>&#123;</span><br><span class="line">  context.hoists.push(exp);</span><br><span class="line">  <span class="keyword">const</span> identifier = createSimpleExpression(<span class="string">`_hoisted_<span class="subst">$&#123;context.hoists.length&#125;</span>`</span>, <span class="literal">false</span>, exp.loc, <span class="literal">true</span>)</span><br><span class="line">  identifier.hoisted = exp</span><br><span class="line">  <span class="keyword">return</span> identifier</span><br><span class="line">&#125;</span><br><span class="line">child.codegenNode = context.hoist(child.codegenNode)</span><br></pre></td></tr></table></figure>
<p>改动后的 codegenNode 会在生成代码阶段帮助我们生成静态提升的相关代码。</p>
<h3 id="createRootCodegen">createRootCodegen</h3>
<p>完成静态提升后，我们来到了 AST 转换的最后一步，即<strong>创建根节点的代码生成节点</strong>。我们先来看一下 createRootCodegen 的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRootCodegen</span>(<span class="params">root, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; helper &#125; = context;</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = root;</span><br><span class="line">  <span class="keyword">const</span> child = children[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (children.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果子节点是单个元素节点，则将其转换成一个 block</span></span><br><span class="line">    <span class="keyword">if</span> (isSingleElementRoot(root, child) &amp;&amp; child.codegenNode) &#123;</span><br><span class="line">      <span class="keyword">const</span> codegenNode = child.codegenNode;</span><br><span class="line">      <span class="keyword">if</span> (codegenNode.type === <span class="number">13</span> <span class="comment">/* VNODE_CALL */</span>) &#123;</span><br><span class="line">        codegenNode.isBlock = <span class="literal">true</span>;</span><br><span class="line">        helper(OPEN_BLOCK);</span><br><span class="line">        helper(CREATE_BLOCK);</span><br><span class="line">      &#125;</span><br><span class="line">      root.codegenNode = codegenNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      root.codegenNode = child;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (children.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果子节点是多个节点，则返回一个 fragement 的代码生成节点</span></span><br><span class="line">    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), <span class="literal">undefined</span>, root.children, <span class="string">`<span class="subst">$&#123;<span class="number">64</span> <span class="regexp">/* STABLE_FRAGMENT */</span>&#125;</span> /* <span class="subst">$&#123;PatchFlagNames[<span class="number">64</span> <span class="regexp">/* STABLE_FRAGMENT */</span>]&#125;</span> */`</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createRootCodegen 做的事情很简单，就是为 root 这个虚拟的 AST 根节点创建一个代码生成节点，如果 root 的子节点 children 是单个元素节点，则将其转换成一个 Block，把这个 child 的 codegenNode 赋值给 root 的 codegenNode。</p>
<p>如果 root 的子节点 children 是多个节点，则返回一个 fragement 的代码生成节点，并赋值给 root 的 codegenNode。</p>
<p>这里，创建 codegenNode 就是为了后续生成代码时使用。</p>
<p>createRootCodegen 完成之后，接着把 transform 上下文在转换 AST 节点过程中创建的一些变量赋值给 root 节点对应的属性，在这里可以看一下这些属性：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root.helpers = [...context.helpers]</span><br><span class="line">root.components = [...context.components]</span><br><span class="line">root.directives = [...context.directives]</span><br><span class="line">root.imports = [...context.imports]</span><br><span class="line">root.hoists = context.hoists</span><br><span class="line">root.temps = context.temps</span><br><span class="line">root.cached = context.cached</span><br></pre></td></tr></table></figure>
<p>这样后续在代码生成节点时，就可以通过 root 这个根节点访问到这些变量了。</p>
<h3 id="总结">总结</h3>
<p>如果说 parse 阶段是一个词法分析过程，构造基础的 AST 节点对象，那么 transform 节点就是语法分析阶段，把 AST 节点做一层转换，构造出语义化更强，信息更加丰富的 codegenCode，它在后续的代码生成阶段起着非常重要的作用。</p>
<h3 id="题外">题外</h3>
<h4 id="最后，给你留一道思考题目，我们已经知道静态提升的好处是，针对静态节点不用每次在-render-阶段都执行一次-createVNode-创建-vnode-对象，但它有没有成本呢？为什么？">最后，给你留一道思考题目，我们已经知道静态提升的好处是，针对静态节点不用每次在 render 阶段都执行一次 createVNode 创建 vnode 对象，但它有没有成本呢？为什么？</h4>
<p>空间(内存)换时间(性能)</p>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/en/vue3-【源码解读】AST 生成可运行代码/" data-toggle="tooltip" data-placement="top" title="[vue3 源码解读] AST生成可运行代码">&larr; Previous Post</a>
          </li>
          
          
          <li class="next">
            <a href="/en/vue3-【源码解读】各个生命周期的执行时机和应用场景/" data-toggle="tooltip" data-placement="top" title="[vue3 源码解读] 各个生命周期的执行时机和应用场景">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      If you like this blog or find it useful for you, you are welcome to comment on it. You are also welcome to share this blog, so that more people can participate in it. If the images used in the blog infringe your copyright, please contact the author to delete them. Thank you !
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: 'be77013e3cb3cb9e89f1',
      clientSecret: '39e9b02a8070f1366c5e87418220c8f375864ab8',
      repo: 'jasonluox',
      owner: 'JasonLuox',
      admin: 'JasonLuox',
      id: 'Mon Sep 20 2021 23:48:17 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">源码地址</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%88%9B%E5%BB%BA-transform-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">创建 transform 上下文</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%81%8D%E5%8E%86-AST-%E8%8A%82%E7%82%B9"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">遍历 AST 节点</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Element-%E8%8A%82%E7%82%B9%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">Element 节点转换函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%8A%82%E7%82%B9%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">表达式节点转换函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Text-%E8%8A%82%E7%82%B9%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">Text 节点转换函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#v-if-%E8%8A%82%E7%82%B9%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">v-if 节点转换函数</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%9D%99%E6%80%81%E6%8F%90%E5%8D%87"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">静态提升</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#createRootCodegen"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">createRootCodegen</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">总结</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%A2%98%E5%A4%96"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">题外</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%9C%80%E5%90%8E%EF%BC%8C%E7%BB%99%E4%BD%A0%E7%95%99%E4%B8%80%E9%81%93%E6%80%9D%E8%80%83%E9%A2%98%E7%9B%AE%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B7%B2%E7%BB%8F%E7%9F%A5%E9%81%93%E9%9D%99%E6%80%81%E6%8F%90%E5%8D%87%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%EF%BC%8C%E9%92%88%E5%AF%B9%E9%9D%99%E6%80%81%E8%8A%82%E7%82%B9%E4%B8%8D%E7%94%A8%E6%AF%8F%E6%AC%A1%E5%9C%A8-render-%E9%98%B6%E6%AE%B5%E9%83%BD%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1-createVNode-%E5%88%9B%E5%BB%BA-vnode-%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BD%86%E5%AE%83%E6%9C%89%E6%B2%A1%E6%9C%89%E6%88%90%E6%9C%AC%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">最后，给你留一道思考题目，我们已经知道静态提升的好处是，针对静态节点不用每次在 render 阶段都执行一次 createVNode 创建 vnode 对象，但它有没有成本呢？为什么？</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">FEATURED TAGS</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#vue3源码" title="vue3源码">vue3源码</a>
            
            <a class="tag" href="/tags/#vue3" title="vue3">vue3</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Jason Luo
          2021
          <br>
          Theme by
          <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="/js/mouseclick.js" content='我要变强，为此不惜一切...,一念往，尽作尘泥罢...,玻璃晴朗，橘子辉煌...,我心即地狱，管他罪孽滔天...,我要这天，再遮不住我眼...,我要这地，再埋不了我心...,斯若晴空，何惧冰寒...,这灯红酒绿的世界啊...,不要放弃，哪怕付出所有...' color='#CDF0EA,#F9F9F9,#F7DBF0,#BEAEE2,#F38181,#FCE38A,#EAFFD0,#95E1D3,#80D6FF'></script>
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="/js/ribbonDynamic.js"></script>
  

  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("https://jasonluox.github.io/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="SEARCH..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"mobile":{"show":"fasle"},"display":{"hOffset":-40,"vOffset":-80},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
