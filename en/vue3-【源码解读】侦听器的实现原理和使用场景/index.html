<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-xxxxxx-xx');
    </script>
  

  <!-- Baidu Tongji -->
  
    <script type="text/javascript">
      // Originial
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc"/>
  <meta name="baidu-site-verification" content="PpzM9WxOJU"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="It&#39;s an IT blog..."/>
  <meta name="keyword" content="HTML,JavaScript,CSS,TypeScript,VUE,WEBPACK,VITE"/>
  <link rel="shortcut icon" href="/img/avatar/logo.jpg"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css"/>
    <link rel="stylesheet" href="/css/widget.css"/>
    <link rel="stylesheet" href="/css/rocket.css"/>
    <link rel="stylesheet" href="/css/signature.css"/>
    <link rel="stylesheet" href="/css/catalog.css"/>
    <link rel="stylesheet" href="/css/livemylife.css"/>

    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css"/>
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="https://jasonluox.github.io/en/vue3-【源码解读】侦听器的实现原理和使用场景/">
  <title>
    
      [vue3 源码解读] 侦听器的实现原理和使用场景 - 流年风尘 | 我的前端之路
    
  </title>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Jason Luo&#39;s Golden House</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">HOME</a>
          </li>

          
          
          
          
          <li>
            <a href="/about/">
              
              ABOUT
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/archive/">
              
              ARCHIVES
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/categories/">
              
              CATEGORIES
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              TAGS
              
              
            </a>
          </li>
          
          

          
          <li>
            <a class="popup-trigger">
              <span class="search-icon"></span>SEARCH</a>
          </li>
          

          <!-- LangSelect -->
          
          
          
          
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/comic/about_stars3.jpg');
      --intro-header-background-image-url-post: url('/img/header_img/scenery/tree_stars.jpg');
      --intro-header-background-image-url-page: url('//img/header_img/scenery/tree_stars.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/comic/about_stars3.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/scenery/tree_stars.jpg');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('//img/header_img/scenery/tree_stars.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url('/img/header_img/scenery/tree_stars.jpg'); */
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/jasonluo-white.png');
      }
    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading" style="height: 200px;">
            <div class="tags">
              
              <a class="tag" href="/tags/#vue3源码" title="vue3源码">vue3源码</a>
              
              <a class="tag" href="/tags/#vue3" title="vue3">vue3</a>
              
            </div>
            <h1>[vue3 源码解读] 侦听器的实现原理和使用场景</h1>
            <h2 class="subheading"></h2>
            <span class="meta">
              Posted by Jason Luo on
              2021-09-06
            </span>


<!--            
            &lt;!&ndash; WordCount start &ndash;&gt;
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">30</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">7.6k</span> In Total
            </span>
            <div class="blank_box"></div>
            &lt;!&ndash; WordCount end &ndash;&gt;
            
            
            &lt;!&ndash; 不蒜子统计 start &ndash;&gt;
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            &lt;!&ndash; 不蒜子统计 end &ndash;&gt;
            -->


          </div>
          
        </div>
      </div>
    </div>
  </div>

  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h3 id="源码地址">源码地址</h3>
<blockquote>
<p>本节课的相关代码在源代码中的位置如下：<br>
packages/runtime-core/src/apiWatch.ts</p>
<p>packages/runtime-core/src/apiWatch.ts<br>
packages/runtime-core/src/scheduler.ts</p>
</blockquote>
<p>在平时的开发工作中，我们经常使用侦听器帮助我们去观察某个数据的变化然后去执行一段逻辑。</p>
<p>在 Vue.js 2.x 中，你可以通过 watch 选项去初始化一个侦听器，称作 watcher：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  watch: &#123; </span><br><span class="line">    <span class="function"><span class="title">a</span>(<span class="params">newVal, oldVal</span>)</span> &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;new: %s,00 old: %s&#x27;</span>, newVal, oldVal) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>当然你也可以通过 $watch API 去创建一个侦听器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;new: %s, old: %s&#x27;</span>, newVal, oldVal) </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<p>与 watch 选项不同，通过 $watch API 创建的侦听器 watcher 会返回一个 unwatch 函数，你可以随时执行它来停止这个 watcher 对数据的侦听，而对于 watch 选项创建的侦听器，它会随着组件的销毁而停止对数据的侦听。</p>
<p>在 Vue.js 3.0 中，虽然你仍可以使用 watch 选项，但针对 Composition API，Vue.js 3.0 提供了 watch API 来实现侦听器的效果。</p>
<h3 id="watch-API-的用法">watch API 的用法</h3>
<p>我们先来看 Vue.js 3.0 中 watch API 有哪些用法。</p>
<ul>
<li>
<p>watch API 可以<strong>侦听一个 getter 函数</strong>，但是它必须返回一个响应式对象，当该响应式对象更新后，会执行对应的回调函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;) </span><br><span class="line">watch(<span class="function">() =&gt;</span> state.count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 当 state.count 更新，会触发此回调函数 </span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>watch API 也可以直接<strong>侦听一个响应式对象</strong>，当响应式对象更新后，会执行对应的回调函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>) </span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 当 count.value 更新，会触发此回调函数 </span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>watch API 还可以直接<strong>侦听多个响应式对象</strong>，任意一个响应式对象更新后，就会执行对应的回调函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>) </span><br><span class="line"><span class="keyword">const</span> count2 = ref(<span class="number">1</span>) </span><br><span class="line">watch([count, count2], <span class="function">(<span class="params">[count, count2], [prevCount, prevCount2]</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 当 count.value 或者 count2.value 更新，会触发此回调函数 </span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="watch-API-实现原理">watch API 实现原理</h3>
<p>侦听器的言下之意就是，当侦听的对象或者函数发生了变化则自动执行某个回调函数，这和我们前面说过的副作用函数 effect 很像， 那它的内部实现是不是依赖了 effect 呢？带着这个疑问，我们来探究 watch API 的具体实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params">source, cb, options</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; !isFunction(cb)) &#123; </span><br><span class="line">    warn(<span class="string">`\`watch(fn, options?)\` signature has been moved to a separate API. `</span> + </span><br><span class="line">      <span class="string">`Use \`watchEffect(fn, options?)\` instead. \`watch\` now only `</span> + </span><br><span class="line">      <span class="string">`supports \`watch(source, cb, options?) signature.`</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> doWatch(source, cb, options) </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 标准化 source </span></span><br><span class="line">  <span class="comment">// 构造 applyCb 回调函数 </span></span><br><span class="line">  <span class="comment">// 创建 scheduler 时序执行函数 </span></span><br><span class="line">  <span class="comment">// 创建 effect 副作用函数 </span></span><br><span class="line">  <span class="comment">// 返回侦听器销毁函数 </span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>从代码中可以看到，watch 函数内部调用了 doWatch 函数，调用前会在非生产环境下判断第二个参数 cb 是不是一个函数，如果不是则会报警告以告诉用户应该使用 watchEffect(fn, options) API，watchEffect API 也是侦听器相关的 API，稍后我们会详细介绍。</p>
<p>这个 doWatch 函数很长，所以我只贴出了需要理解的部分，我用注释将这个函数的实现逻辑拆解成了几个步骤。可以看到，内部确实创建了 effect 副作用函数。接下来，就随我一步步看它具体做了哪些事情吧。</p>
<h4 id="标准化-source">标准化 source</h4>
<p>我们先来看watch 函数的第一个参数 source。</p>
<p>通过前文知道 source 可以是 getter 函数，也可以是响应式对象甚至是响应式对象数组，所以我们需要标准化 source，这是标准化 source 的流程：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source 不合法的时候会报警告 </span></span><br><span class="line"><span class="keyword">const</span> warnInvalidSource = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123; </span><br><span class="line">  warn(<span class="string">`Invalid watch source: `</span>, s, <span class="string">`A watch source can only be a getter/effect function, a ref, `</span> + </span><br><span class="line">    <span class="string">`a reactive object, or an array of these types.`</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 当前组件实例 </span></span><br><span class="line"><span class="keyword">const</span> instance = currentInstance </span><br><span class="line"><span class="keyword">let</span> getter </span><br><span class="line"><span class="keyword">if</span> (isArray(source)) &#123; </span><br><span class="line">  getter = <span class="function">() =&gt;</span> source.map(<span class="function"><span class="params">s</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (isRef(s)) &#123; </span><br><span class="line">      <span class="keyword">return</span> s.value </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(s)) &#123; </span><br><span class="line">      <span class="keyword">return</span> traverse(s) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(s)) &#123; </span><br><span class="line">      <span class="keyword">return</span> callWithErrorHandling(s, instance, <span class="number">2</span> <span class="comment">/* WATCH_GETTER */</span>) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; warnInvalidSource(s) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isRef(source)) &#123; </span><br><span class="line">  getter = <span class="function">() =&gt;</span> source.value </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isReactive(source)) &#123; </span><br><span class="line">  getter = <span class="function">() =&gt;</span> source </span><br><span class="line">  deep = <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isFunction(source)) &#123; </span><br><span class="line">  <span class="keyword">if</span> (cb) &#123; </span><br><span class="line">    <span class="comment">// getter with cb </span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> callWithErrorHandling(source, instance, <span class="number">2</span> <span class="comment">/* WATCH_GETTER */</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// watchEffect 的逻辑 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">  getter = NOOP </span><br><span class="line">  (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; warnInvalidSource(source) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (cb &amp;&amp; deep) &#123; </span><br><span class="line">  <span class="keyword">const</span> baseGetter = getter </span><br><span class="line">  getter = <span class="function">() =&gt;</span> traverse(baseGetter()) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>其实，source 标准化主要是根据 source 的类型，将其变成 getter 函数。具体来说：</p>
<ul>
<li>如果 source 是 ref 对象，则创建一个访问 source.value 的 getter 函数;</li>
<li>如果 source 是 reactive 对象，则创建一个访问 source 的 getter 函数，并设置 deep 为 true</li>
<li>如果 source 是一个函数，则会进一步判断第二个参数 cb 是否存在，对于 watch API 来说，cb 是一定存在且是一个回调函数，这种情况下，getter 就是一个简单的对 source 函数封装的函数。</li>
</ul>
<p>如果 source 不满足上述条件，则在非生产环境下报警告，提示 source 类型不合法。</p>
<p>我们来看一下最终标准化生成的 getter 函数，它会返回一个响应式对象，在后续创建 effect runner 副作用函数需要用到，每次执行 runner 就会把 getter 函数返回的响应式对象作为 watcher 求值的结果</p>
<p>最后我们来关注一下 deep 为 true 的情况。此时，我们会发现生成的 getter 函数会被 traverse 函数包装一层。traverse 函数的实现很简单，即通过递归的方式访问 value 的每一个子属性。那么，为什么要递归访问每一个子属性呢？</p>
<p>其实 deep 属于 watcher 的一个配置选项，Vue.js 2.x 也支持，表面含义是深度侦听，实际上是通过遍历对象的每一个子属性来实现。举个例子你就明白了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; </span><br><span class="line">  count: &#123; </span><br><span class="line">    a: &#123; </span><br><span class="line">      b: <span class="number">1</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;) </span><br><span class="line">watch(state.count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(count) </span><br><span class="line">&#125;) </span><br><span class="line">state.count.a.b = <span class="number">2</span>  </span><br></pre></td></tr></table></figure>
<p>这里，我们利用 reactive API 创建了一个嵌套层级较深的响应式对象 state，然后再调用 watch API 侦听 state.count 的变化。接下来我们修改内部属性 state.count.a.b 的值，你会发现 watcher 的回调函数执行了，为什么会执行呢？</p>
<p>学过响应式章节，我们知道只有对象属性先被访问触发了依赖收集，再去修改这个属性，才可以通知对应的依赖更新。而从上述业务代码来看，我们修改 state.count.a.b 的值时并没有访问它 ，但还是触发了 watcher 的回调函数。</p>
<p>根本原因是，当我们执行 watch 函数的时候，我们知道如果侦听的是一个 reactive 对象，那么内部会设置 deep 为 true，然后执行 traverse 去递归访问对象深层子属性，这个时候就会访问 state.count.a.b 触发依赖收集，这里收集的依赖是 watcher 内部创建的 effect runner。因此，当我们再去修改 state.count.a.b 的时候，就会通知这个 effect ，所以最终会执行 watcher 的回调函数。</p>
<p>当我们侦听一个通过 reactive API 创建的响应式对象时，内部会执行 traverse 函数，如果这个对象非常复杂，比如嵌套层级很深，那么递归 traverse 就会有一定的性能耗时。因此如果我们需要侦听这个复杂响应式对象内部的某个具体属性，就可以想办法减少 traverse 带来的性能损耗。</p>
<p>比如刚才的例子，我们就可以直接侦听 state.count.a.b 的变化：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch(state.count.a, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(newVal) </span><br><span class="line">&#125;) </span><br><span class="line">state.count.a.b = <span class="number">2</span> </span><br></pre></td></tr></table></figure>
<p>这样就可以减少内部执行 traverse 的次数。你可能会问，直接侦听 state.count.a.b 可以吗？答案是不行，因为 state.count.a.b 已经是一个基础数字类型了，不符合 source 要求的参数类型，所以会在非生产环境下报警告。</p>
<p>那么有没有办法优化使得 traverse 不执行呢？答案是可以的。我们可以侦听一个 getter 函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="function">() =&gt;</span> state.count.a.b, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(newVal) </span><br><span class="line">&#125;) </span><br><span class="line">state.count.a.b = <span class="number">2</span> </span><br></pre></td></tr></table></figure>
<p>这样函数内部会访问并返回 state.count.a.b，一次 traverse 都不会执行并且依然可以侦听到它的变化从而执行 watcher 的回调函数。</p>
<h4 id="构造回调函数">构造回调函数</h4>
<p>处理完 watch API 第一个参数 source 后，接下来处理第二个参数 cb。</p>
<p>cb 是一个回调函数，它有三个参数：第一个 newValue 代表新值；第二个 oldValue 代表旧值。第三个参数 onInvalidate，我打算放在后面介绍。</p>
<p>其实这样的 API 设计非常好理解，即侦听一个值的变化，如果值变了就执行回调函数，回调函数里可以访问到新值和旧值。</p>
<p>接下来我们来看一下构造回调函数的处理逻辑：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cleanup </span><br><span class="line"><span class="comment">// 注册无效回调函数 </span></span><br><span class="line"><span class="keyword">const</span> onInvalidate = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123; </span><br><span class="line">  cleanup = runner.options.onStop = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    callWithErrorHandling(fn, instance, <span class="number">4</span> <span class="comment">/* WATCH_CLEANUP */</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 旧值初始值 </span></span><br><span class="line"><span class="keyword">let</span> oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE <span class="comment">/*&#123;&#125;*/</span> </span><br><span class="line"><span class="comment">// 回调函数 </span></span><br><span class="line"><span class="keyword">const</span> applyCb = cb </span><br><span class="line">  ? <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 组件销毁，则直接返回 </span></span><br><span class="line">    <span class="keyword">if</span> (instance &amp;&amp; instance.isUnmounted) &#123; </span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 求得新值 </span></span><br><span class="line">    <span class="keyword">const</span> newValue = runner() </span><br><span class="line">    <span class="keyword">if</span> (deep || hasChanged(newValue, oldValue)) &#123; </span><br><span class="line">      <span class="comment">// 执行清理函数 </span></span><br><span class="line">      <span class="keyword">if</span> (cleanup) &#123; </span><br><span class="line">        cleanup() </span><br><span class="line">      &#125; </span><br><span class="line">      callWithAsyncErrorHandling(cb, instance, <span class="number">3</span> <span class="comment">/* WATCH_CALLBACK */</span>, [ </span><br><span class="line">        newValue, </span><br><span class="line">        <span class="comment">// 第一次更改时传递旧值为 undefined </span></span><br><span class="line">        oldValue === INITIAL_WATCHER_VALUE ? <span class="literal">undefined</span> : oldValue, </span><br><span class="line">        onInvalidate </span><br><span class="line">      ]) </span><br><span class="line">      <span class="comment">// 更新旧值 </span></span><br><span class="line">      oldValue = newValue </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  : <span class="built_in">void</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<p>onInvalidate 函数用来注册无效回调函数 ，我们暂时不需要关注它，我们需要重点来看 applyCb。 这个函数实际上就是对 cb 做一层封装，当侦听的值发生变化时就会执行 applyCb 方法，我们来分析一下它的实现。</p>
<p>首先，watch API 和组件实例相关，因为通常我们会在组件的 setup 函数中使用它，当组件销毁后，回调函数 cb 不应该被执行而是直接返回。</p>
<p>接着，执行 runner 求得新值，这里实际上就是执行前面创建的 getter 函数求新值。</p>
<p>最后进行判断，如果是 deep 的情况或者新旧值发生了变化，则执行回调函数 cb，传入参数 newValue 和 oldValue。注意，第一次执行的时候旧值的初始值是空数组或者 undefined。执行完回调函数 cb 后，把旧值 oldValue 再更新为 newValue，这是为了下一次的比对。</p>
<h4 id="创建-scheduler">创建 scheduler</h4>
<p>scheduler 的作用是根据某种调度的方式去执行某种函数，在 watch API 中，主要影响到的是回调函数的执行方式。我们来看一下它的实现逻辑：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invoke = <span class="function">(<span class="params">fn</span>) =&gt;</span> fn() </span><br><span class="line"><span class="keyword">let</span> scheduler </span><br><span class="line"><span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123; </span><br><span class="line">  <span class="comment">// 同步 </span></span><br><span class="line">  scheduler = invoke </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;pre&#x27;</span>) &#123; </span><br><span class="line">  scheduler = <span class="function"><span class="params">job</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (!instance || instance.isMounted) &#123; </span><br><span class="line">      <span class="comment">// 进入异步队列，组件更新前执行 </span></span><br><span class="line">      queueJob(job) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// 如果组件还没挂载，则同步执行确保在组件挂载前 </span></span><br><span class="line">      job() </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="comment">// 进入异步队列，组件更新后执行 </span></span><br><span class="line">  scheduler = <span class="function"><span class="params">job</span> =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Watch API 的参数除了 source 和 cb，还支持第三个参数 options，不同的配置决定了 watcher 的不同行为。前面我们也分析了 deep 为 true 的情况，除了 source 为 reactive 对象时会默认把 deep 设置为 true，你也可以主动传入第三个参数，把 deep 设置为 true。</p>
<p>这里，scheduler 的创建逻辑受到了第三个参数 Options 中的 flush 属性值的影响，不同的 flush 决定了 watcher 的执行时机。</p>
<p>当 flush 为 sync 的时候，表示它是一个同步 watcher，即当数据变化时同步执行回调函数。</p>
<p>当 flush 为 pre 的时候，回调函数通过 queueJob 的方式在组件更新之前执行，如果组件还没挂载，则同步执行确保回调函数在组件挂载之前执行。</p>
<p>如果没设置 flush，那么回调函数通过 queuePostRenderEffect 的方式在组件更新之后执行。</p>
<p>queueJob 和 queuePostRenderEffect 在这里不是重点，所以我们放到后面介绍。总之，你现在要记住，<strong>watcher 的回调函数是通过一定的调度方式执行的</strong>。</p>
<h4 id="创建-effect">创建 effect</h4>
<p>前面的分析我们提到了 runner，它其实就是 watcher 内部创建的 effect 函数，接下来，我们来分析它逻辑：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> runner = effect(getter, &#123; </span><br><span class="line">  <span class="comment">// 延时执行 </span></span><br><span class="line">  lazy: <span class="literal">true</span>, </span><br><span class="line">  <span class="comment">// computed effect 可以优先于普通的 effect 先运行，比如组件渲染的 effect </span></span><br><span class="line">  computed: <span class="literal">true</span>, </span><br><span class="line">  onTrack, </span><br><span class="line">  onTrigger, </span><br><span class="line">  scheduler: applyCb ? <span class="function">() =&gt;</span> scheduler(applyCb) : scheduler </span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// 在组件实例中记录这个 effect </span></span><br><span class="line">recordInstanceBoundEffect(runner) </span><br><span class="line"><span class="comment">// 初次执行 </span></span><br><span class="line"><span class="keyword">if</span> (applyCb) &#123; </span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123; </span><br><span class="line">    applyCb() </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 求旧值 </span></span><br><span class="line">    oldValue = runner() </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="comment">// 没有 cb 的情况 </span></span><br><span class="line">  runner() </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这块代码逻辑是整个 watcher 实现的核心部分，即通过 effect API 创建一个副作用函数 runner，我们需要关注以下几点。</p>
<ul>
<li>
<p><strong>runner 是一个 computed effect</strong>。因为 computed effect 可以优先于普通的 effect（比如组件渲染的 effect）先运行，这样就可以实现当配置 flush 为 pre 的时候，watcher 的执行可以优先于组件更新。</p>
</li>
<li>
<p><strong>runner 执行的方式</strong>。runner 是 lazy 的，它不会在创建后立刻执行。第一次手动执行 runner 会执行前面的 getter 函数，访问响应式数据并做依赖收集。注意，此时activeEffect 就是 runner，这样在后面更新响应式数据时，就可以触发 runner 执行 scheduler 函数，以一种调度方式来执行回调函数。</p>
</li>
<li>
<p><strong>runner 的返回结果</strong>。手动执行 runner 就相当于执行了前面标准化的 getter 函数，getter 函数的返回值就是 watcher 计算出的值，所以我们第一次执行 runner 求得的值可以作为 oldValue。</p>
</li>
<li>
<p><strong>配置了 immediate 的情况</strong>。当我们配置了 immediate ，创建完 watcher 会立刻执行 applyCb 函数，此时 oldValue 还是初始值，在 applyCb 执行时也会执行 runner 进而执行前面的 getter 函数做依赖收集，求得新值。</p>
</li>
</ul>
<h4 id="返回销毁函数">返回销毁函数</h4>
<p>最后，会返回侦听器销毁函数，也就是 watch API 执行后返回的函数。我们可以通过调用它来停止 watcher 对数据的侦听。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  stop(runner) </span><br><span class="line">  <span class="keyword">if</span> (instance) &#123; </span><br><span class="line">    <span class="comment">// 移除组件 effects 对这个 runner 的引用 </span></span><br><span class="line">    remove(instance.effects, runner) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stop</span>(<span class="params">effect</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (effect.active) &#123; </span><br><span class="line">    cleanup(effect) </span><br><span class="line">    <span class="keyword">if</span> (effect.options.onStop) &#123; </span><br><span class="line">      effect.options.onStop() </span><br><span class="line">    &#125; </span><br><span class="line">    effect.active = <span class="literal">false</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>销毁函数内部会执行 stop 方法让 runner 失活，并清理 runner 的相关依赖，这样就可以停止对数据的侦听。并且，如果是在组件中注册的 watcher，也会移除组件 effects 对这个 runner 的引用。</p>
<h3 id="异步任务队列">异步任务队列</h3>
<h4 id="异步任务队列的设计">异步任务队列的设计</h4>
<p>在前面的课时中，我们多次提到回调函数是以一种调度的方式执行的，特别是当 flush 不是 sync 时，它会把回调函数执行的任务推到一个异步队列中执行。接下来，我们就来分析异步执行队列的设计。分析之前，我们先来思考一下，为什么会需要异步队列？</p>
<p>我们把之前的例子简单修改一下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;) </span><br><span class="line">watch(<span class="function">() =&gt;</span> state.count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(count) </span><br><span class="line">&#125;) </span><br><span class="line">state.count++ </span><br><span class="line">state.count++ </span><br><span class="line">state.count++ </span><br></pre></td></tr></table></figure>
<p>这里，我们修改了三次 state.count，那么 watcher 的回调函数会执行三次吗？</p>
<p>答案是不会，实际上只输出了一次 count 的值，也就是最终计算的值 3。这在大多数场景下都是符合预期的，因为在一个 Tick（宏任务执行的生命周期）内，即使多次修改侦听的值，它的回调函数也只执行一次。</p>
<blockquote>
<p>知识延伸<br>
组件的更新过程是异步的，我们知道修改模板中引用的响应式对象的值时，会触发组件的重新渲染，但是在一个 Tick 内，即使你多次修改多个响应式对象的值，组件的重新渲染也只执行一次。这是因为如果每次更新数据都触发组件重新渲染，那么重新渲染的次数和代价都太高了。</p>
</blockquote>
<p>那么，这是怎么做到的呢？我们先从异步任务队列的创建说起。</p>
<blockquote>
<p>TODO 以上的解释有误，这里会执行三次</p>
</blockquote>
<h4 id="异步任务队列的创建">异步任务队列的创建</h4>
<p>通过前面的分析我们知道，在创建一个 watcher 时，如果配置 flush 为 pre 或不配置 flush ，那么 watcher 的回调函数就会异步执行。此时分别是通过 queueJob 和 queuePostRenderEffect 把回调函数推入异步队列中的。</p>
<p>在不涉及 suspense 的情况下，queuePostRenderEffect 相当于 queuePostFlushCb，我们来看它们的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步任务队列 </span></span><br><span class="line"><span class="keyword">const</span> queue = [] </span><br><span class="line"><span class="comment">// 队列任务执行完后执行的回调函数队列 </span></span><br><span class="line"><span class="keyword">const</span> postFlushCbs = [] </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueJob</span>(<span class="params">job</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!queue.includes(job)) &#123; </span><br><span class="line">    queue.push(job) </span><br><span class="line">    queueFlush() </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queuePostFlushCb</span>(<span class="params">cb</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!isArray(cb)) &#123; </span><br><span class="line">    postFlushCbs.push(cb) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 如果是数组，把它拍平成一维 </span></span><br><span class="line">    postFlushCbs.push(...cb) </span><br><span class="line">  &#125; </span><br><span class="line">  queueFlush() </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Vue.js 内部维护了一个 queue 数组和一个 postFlushCbs 数组，其中 queue 数组用作异步任务队列， postFlushCbs 数组用作异步任务队列执行完毕后的回调函数队列。</p>
<p>执行 queueJob 时会把这个任务 job 添加到 queue 的队尾，而执行 queuePostFlushCb 时，会把这个 cb 回调函数添加到 postFlushCbs 的队尾。它们在添加完毕后都执行了 queueFlush 函数，我们接着看它的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve() </span><br><span class="line"><span class="comment">// 异步任务队列是否正在执行 </span></span><br><span class="line"><span class="keyword">let</span> isFlushing = <span class="literal">false</span> </span><br><span class="line"><span class="comment">// 异步任务队列是否等待执行 </span></span><br><span class="line"><span class="keyword">let</span> isFlushPending = <span class="literal">false</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> fn ? p.then(fn) : p </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123; </span><br><span class="line">    isFlushPending = <span class="literal">true</span> </span><br><span class="line">    nextTick(flushJobs) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到，Vue.js 内部还维护了 isFlushing 和 isFlushPending 变量，用来控制异步任务的刷新逻辑。</p>
<p>在 queueFlush 首次执行时，isFlushing 和 isFlushPending 都是 false，此时会把 isFlushPending 设置为 true，并且调用 nextTick(flushJobs) 去执行队列里的任务。</p>
<p>因为 isFlushPending 的控制，这使得即使多次执行 queueFlush，也不会多次去执行 flushJobs。另外 nextTick 在 Vue.js 3.0 中的实现也是非常简单，通过 Promise.resolve().then 去异步执行 flushJobs。</p>
<p>因为 JavaScript 是单线程执行的，这样的异步设计使你在一个 Tick 内，可以多次执行 queueJob 或者 queuePostFlushCb 去添加任务，也可以保证在宏任务执行完毕后的微任务阶段执行一次 flushJobs。</p>
<h4 id="异步任务队列的执行">异步任务队列的执行</h4>
<p>创建完任务队列后，接下来要异步执行这个队列，我们来看一下 flushJobs 的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getId = <span class="function">(<span class="params">job</span>) =&gt;</span> (job.id == <span class="literal">null</span> ? <span class="literal">Infinity</span> : job.id) </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params">seen</span>) </span>&#123; </span><br><span class="line">  isFlushPending = <span class="literal">false</span> </span><br><span class="line">  isFlushing = <span class="literal">true</span> </span><br><span class="line">  <span class="keyword">let</span> job </span><br><span class="line">  <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">    seen = seen || <span class="keyword">new</span> <span class="built_in">Map</span>() </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 组件的更新是先父后子 </span></span><br><span class="line">  <span class="comment">// 如果一个组件在父组件更新过程中卸载，它自身的更新应该被跳过 </span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> getId(a) - getId(b)) </span><br><span class="line">  <span class="keyword">while</span> ((job = queue.shift()) !== <span class="literal">undefined</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (job === <span class="literal">null</span>) &#123; </span><br><span class="line">      <span class="keyword">continue</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">      checkRecursiveUpdates(seen, job) </span><br><span class="line">    &#125; </span><br><span class="line">    callWithErrorHandling(job, <span class="literal">null</span>, <span class="number">14</span> <span class="comment">/* SCHEDULER */</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  flushPostFlushCbs(seen) </span><br><span class="line">  isFlushing = <span class="literal">false</span> </span><br><span class="line">  <span class="comment">// 一些 postFlushCb 执行过程中会再次添加异步任务，递归 flushJobs 会把它们都执行完毕 </span></span><br><span class="line">  <span class="keyword">if</span> (queue.length || postFlushCbs.length) &#123; </span><br><span class="line">    flushJobs(seen) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到，flushJobs 函数开始执行的时候，会把 isFlushPending 重置为 false，把 isFlushing 设置为 true 来表示正在执行异步任务队列。</p>
<p>对于异步任务队列 queue，在遍历执行它们前会先对它们做一次从小到大的排序，这是因为两个主要原因：</p>
<ul>
<li>我们创建组件的过程是由父到子，所以创建组件副作用渲染函数也是先父后子，父组件的副作用渲染函数的 effect id 是小于子组件的，每次更新组件也是通过 queueJob 把 effect 推入异步任务队列 queue 中的。所以为了保证先更新父组再更新子组件，要对 queue 做从小到大的排序。</li>
<li>如果一个组件在父组件更新过程中被卸载，它自身的更新应该被跳过。所以也应该要保证先更新父组件再更新子组件，要对 queue 做从小到大的排序。</li>
</ul>
<p>接下来，就是遍历这个 queue，依次执行队列中的任务了，在遍历过程中，注意有一个 checkRecursiveUpdates 的逻辑，它是用来在非生产环境下检测是否有循环更新的，它的作用我们稍后会提。</p>
<p>遍历完 queue 后，又会进一步执行 flushPostFlushCbs 方法去遍历执行所有推入到 postFlushCbs 的回调函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">flushPostFlushCbs</span>(<span class="params">seen</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (postFlushCbs.length) &#123; </span><br><span class="line">    <span class="comment">// 拷贝副本 </span></span><br><span class="line">    <span class="keyword">const</span> cbs = [...new <span class="built_in">Set</span>(postFlushCbs)] </span><br><span class="line">    postFlushCbs.length = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">      seen = seen || <span class="keyword">new</span> <span class="built_in">Map</span>() </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.length; i++) &#123; </span><br><span class="line">      <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)) &#123;                                                       </span><br><span class="line">        checkRecursiveUpdates(seen, cbs[i]) </span><br><span class="line">      &#125; </span><br><span class="line">      cbs[i]() </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>注意这里遍历前会通过 const cbs = […new Set(postFlushCbs)] 拷贝一个 postFlushCbs 的副本，这是因为在遍历的过程中，可能某些回调函数的执行会再次修改 postFlushCbs，所以拷贝一个副本循环遍历则不会受到 postFlushCbs 修改的影响。</p>
<p>遍历完 postFlushCbs 后，会重置 isFlushing 为 false，因为一些 postFlushCb 执行过程中可能会再次添加异步任务，所以需要继续判断如果 queue 或者 postFlushCbs 队列中还存在任务，则递归执行 flushJobs 把它们都执行完毕。</p>
<h4 id="检测循环更新">检测循环更新</h4>
<p>前面我们提到了，在遍历执行异步任务和回调函数的过程中，都会在非生产环境下执行 checkRecursiveUpdates 检测是否有循环更新，它是用来解决什么问题的呢？</p>
<p>我们把之前的例子改写一下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;) </span><br><span class="line">watch(<span class="function">() =&gt;</span> state.count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  state.count++ </span><br><span class="line">  <span class="built_in">console</span>.log(count) </span><br><span class="line">&#125;) </span><br><span class="line">state.count++ </span><br></pre></td></tr></table></figure>
<p>如果你去跑这个示例，你会在控制台看到输出了 101 次值，然后报了错误： Maximum recursive updates exceeded 。这是因为我们在 watcher 的回调函数里更新了数据，这样会再一次进入回调函数，如果我们不加任何控制，那么回调函数会一直执行，直到把内存耗尽造成浏览器假死。<br>
为了避免这种情况，Vue.js 实现了 checkRecursiveUpdates 方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RECURSION_LIMIT = <span class="number">100</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkRecursiveUpdates</span>(<span class="params">seen, fn</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!seen.has(fn)) &#123; </span><br><span class="line">    seen.set(fn, <span class="number">1</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> count = seen.get(fn) </span><br><span class="line">    <span class="keyword">if</span> (count &gt; RECURSION_LIMIT) &#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Maximum recursive updates exceeded. &#x27;</span> + </span><br><span class="line">        <span class="string">&quot;You may have code that is mutating state in your component&#x27;s &quot;</span> + </span><br><span class="line">        <span class="string">&#x27;render function or updated hook or watcher source function.&#x27;</span>) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      seen.set(fn, count + <span class="number">1</span>) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>通过前面的代码，我们知道 flushJobs 一开始便创建了 seen，它是一个 Map 对象，然后在 checkRecursiveUpdates 的时候会把任务添加到 seen 中，记录引用计数 count，初始值为 1，如果 postFlushCbs 再次添加了相同的任务，则引用计数 count 加 1，如果 count 大于我们定义的限制 100 ，则说明一直在添加这个相同的任务并超过了 100 次。那么，Vue.js 会抛出这个错误，因为在正常的使用中，不应该出现这种情况，而我们上述的错误示例就会触发这种报错逻辑。</p>
<h4 id="优化：只用一个变量">优化：只用一个变量</h4>
<p>到这里，异步队列的设计就介绍完毕了，你可能会对 isFlushPending 和 isFlushing 有些疑问，为什么需要两个变量来控制呢？</p>
<p>从语义上来看，isFlushPending 用于判断是否在等待 nextTick 执行 flushJobs，而 isFlushing 是判断是否正在执行任务队列。</p>
<p>从功能上来看，它们的作用是为了确保以下两点：</p>
<ul>
<li>
<p>在一个 Tick 内可以多次添加任务到队列中，但是任务队列会在 nextTick 后执行；</p>
</li>
<li>
<p>在执行任务队列的过程中，也可以添加新的任务到队列中，并且在当前 Tick 去执行剩余的任务队列。</p>
</li>
</ul>
<p>但实际上，这里我们可以进行优化。在我看来，这里用一个变量就足够了，我们来稍微修改一下源码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!isFlushing) &#123; </span><br><span class="line">    isFlushing = <span class="literal">true</span> </span><br><span class="line">    nextTick(flushJobs) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params">seen</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">let</span> job </span><br><span class="line">  <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">    seen = seen || <span class="keyword">new</span> <span class="built_in">Map</span>() </span><br><span class="line">  &#125; </span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> getId(a) - getId(b)) </span><br><span class="line">  <span class="keyword">while</span> ((job = queue.shift()) !== <span class="literal">undefined</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (job === <span class="literal">null</span>) &#123; </span><br><span class="line">      <span class="keyword">continue</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">      checkRecursiveUpdates(seen, job) </span><br><span class="line">    &#125; </span><br><span class="line">    callWithErrorHandling(job, <span class="literal">null</span>, <span class="number">14</span> <span class="comment">/* SCHEDULER */</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  flushPostFlushCbs(seen) </span><br><span class="line">  <span class="keyword">if</span> (queue.length || postFlushCbs.length) &#123; </span><br><span class="line">    flushJobs(seen) </span><br><span class="line">  &#125; </span><br><span class="line">  isFlushing = <span class="literal">false</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到，我们只需要一个 isFlushing 来控制就可以实现相同的功能了。在执行 queueFlush 的时候，判断 isFlushing 为 false，则把它设置为 true，然后 nextTick 会执行 flushJobs。在 flushJobs 函数执行完成的最后，也就是所有的任务（包括后添加的）都执行完毕，再设置 isFlushing 为 false。</p>
<p>了解完 watch API 和异步任务队列的设计后，我们再来学习侦听器提供的另一个 API—— watchEffect API。</p>
<h3 id="watchEffect-API">watchEffect API</h3>
<p>watchEffect API 的作用是注册一个副作用函数，副作用函数内部可以访问到响应式对象，当内部响应式对象变化后再立即执行这个函数。</p>
<p>可以先来看一个示例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>) </span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(count.value)) </span><br><span class="line">count.value++ </span><br></pre></td></tr></table></figure>
<p>它的结果是依次输出 0 和 1。<br>
watchEffect 和前面的 watch API 有哪些不同呢？主要有三点：</p>
<ol>
<li><strong>侦听的源不同</strong> 。watch API 可以侦听一个或多个响应式对象，也可以侦听一个 getter 函数，而 watchEffect API 侦听的是一个普通函数，只要内部访问了响应式对象即可，这个函数并不需要返回响应式对象。</li>
<li><strong>没有回调函数</strong> 。watchEffect API 没有回调函数，副作用函数的内部响应式对象发生变化后，会再次执行这个副作用函数。</li>
<li><strong>立即执行</strong> 。watchEffect API 在创建好 watcher 后，会立刻执行它的副作用函数，而 watch API 需要配置 immediate 为 true，才会立即执行回调函数。</li>
</ol>
<p>对 watchEffect API 有大体了解后，我们来看一下在我整理的 watchEffect 场景下， doWatch 函数的简化版实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect, options</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> doWatch(effect, <span class="literal">null</span>, options); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) </span>&#123; </span><br><span class="line">  instance = currentInstance; </span><br><span class="line">  <span class="keyword">let</span> getter; </span><br><span class="line">  <span class="keyword">if</span> (isFunction(source)) &#123; </span><br><span class="line">    getter = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (instance &amp;&amp; instance.isUnmounted) &#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">      &#125; </span><br><span class="line">       <span class="comment">// 执行清理函数 </span></span><br><span class="line">      <span class="keyword">if</span> (cleanup) &#123; </span><br><span class="line">        cleanup(); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 执行 source 函数，传入 onInvalidate 作为参数 </span></span><br><span class="line">      <span class="keyword">return</span> callWithErrorHandling(source, instance, <span class="number">3</span> <span class="comment">/* WATCH_CALLBACK */</span>, [onInvalidate]); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">let</span> cleanup; </span><br><span class="line">  <span class="keyword">const</span> onInvalidate = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123; </span><br><span class="line">    cleanup = runner.options.onStop = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      callWithErrorHandling(fn, instance, <span class="number">4</span> <span class="comment">/* WATCH_CLEANUP */</span>); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="keyword">let</span> scheduler; </span><br><span class="line">  <span class="comment">// 创建 scheduler </span></span><br><span class="line">  <span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123; </span><br><span class="line">    scheduler = invoke; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;pre&#x27;</span>) &#123; </span><br><span class="line">    scheduler = <span class="function"><span class="params">job</span> =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (!instance || instance.isMounted) &#123; </span><br><span class="line">        queueJob(job); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> &#123; </span><br><span class="line">        job(); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    scheduler = <span class="function"><span class="params">job</span> =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 创建 runner </span></span><br><span class="line">  <span class="keyword">const</span> runner = effect(getter, &#123; </span><br><span class="line">    lazy: <span class="literal">true</span>, </span><br><span class="line">    computed: <span class="literal">true</span>, </span><br><span class="line">    onTrack, </span><br><span class="line">    onTrigger, </span><br><span class="line">    scheduler </span><br><span class="line">  &#125;); </span><br><span class="line">  recordInstanceBoundEffect(runner); </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 立即执行 runner </span></span><br><span class="line">  runner(); </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 返回销毁函数 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    stop(runner); </span><br><span class="line">    <span class="keyword">if</span> (instance) &#123; </span><br><span class="line">      remove(instance.effects, runner); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到，getter 函数就是对 source 函数的简单封装，它会先判断组件实例是否已经销毁，然后每次执行 source 函数前执行 cleanup 清理函数。</p>
<p>watchEffect 内部创建的 runner 对应的 scheduler 对象就是 scheduler 函数本身，这样它再次执行时，就会执行这个 scheduler 函数，并且传入 runner 函数作为参数，其实就是按照一定的调度方式去执行基于 source 封装的 getter 函数。</p>
<p>创建完 runner 后就立刻执行了 runner，其实就是内部同步执行了基于 source 封装的 getter 函数。</p>
<p>在执行 source 函数的时候，会传入一个 onInvalidate 函数作为参数，接下来我们就来分析它的作用。</p>
<h4 id="注册无效函数">注册无效函数</h4>
<p>有些时候，watchEffect 会注册一个副作用函数，在函数内部可以做一些异步操作，但是当这个 watcher 停止后，如果我们想去对这个异步操作做一些额外事情（比如取消这个异步操作），我们可以通过 onInvalidate 参数注册一个无效函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> id = ref(<span class="number">0</span>) </span><br><span class="line">watchEffect(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 执行异步操作 </span></span><br><span class="line">  <span class="keyword">const</span> token = performAsyncOperation(id.value) </span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 如果 id 发生变化或者 watcher 停止了，则执行逻辑取消前面的异步操作 </span></span><br><span class="line">    token.cancel() </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<p>我们利用 watchEffect 注册了一个副作用函数，它有一个 onInvalidate 参数。在这个函数内部通过 performAsyncOperation 执行某些异步操作，并且访问了 id 这个响应式对象，然后通过 onInvalidate 注册了一个回调函数。</p>
<p>如果 id 发生变化或者 watcher 停止了，这个回调函数将会执行，然后执行 token.cancel 取消之前的异步操作。</p>
<p>我们来回顾 onInvalidate 在 doWatch 中的实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onInvalidate = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123; </span><br><span class="line">  cleanup = runner.options.onStop = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    callWithErrorHandling(fn, instance, <span class="number">4</span> <span class="comment">/* WATCH_CLEANUP */</span>); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>实际上，当你执行 onInvalidate 的时候，就是注册了一个 cleanup 和 runner 的 onStop 方法，这个方法内部会执行 fn，也就是你注册的无效回调函数。</p>
<p>也就是说当响应式数据发生变化，会执行 cleanup 方法，当 watcher 被停止，会执行 onStop 方法，这两者都会执行注册的无效回调函数 fn。</p>
<p>通过这种方式，Vue.js 就很好地实现了 watcher 注册无效回调函数的需求。</p>
<h4 id="总结">总结</h4>
<p>相比于计算属性，侦听器更适合用于在数据变化后执行某段逻辑的场景，而计算属性则用于一个数据依赖另外一些数据计算而来的场景。</p>
<p>最后，给你留一道思考题目，在组件中创建的自定义 watcher，在组件销毁的时候会被销毁吗？是如何做的呢？欢迎你在留言区与我分享。</p>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/en/vue3-【源码解读】依赖注入：子孙组件如何共享数据？/" data-toggle="tooltip" data-placement="top" title="[vue3 源码解读] 依赖注入：子孙组件如何共享数据？">&larr; Previous Post</a>
          </li>
          
          
          <li class="next">
            <a href="/en/vue3-Vuejs3.2新特性及部分优化/" data-toggle="tooltip" data-placement="top" title="[vue3 源码解读] Vuejs3.2新特性及优化">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      If you like this blog or find it useful for you, you are welcome to comment on it. You are also welcome to share this blog, so that more people can participate in it. If the images used in the blog infringe your copyright, please contact the author to delete them. Thank you !
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: 'be77013e3cb3cb9e89f1',
      clientSecret: '39e9b02a8070f1366c5e87418220c8f375864ab8',
      repo: 'jasonluox',
      owner: 'JasonLuox',
      admin: 'JasonLuox',
      id: 'Mon Sep 06 2021 23:16:17 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">源码地址</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#watch-API-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">watch API 的用法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#watch-API-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">watch API 实现原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A0%87%E5%87%86%E5%8C%96-source"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">标准化 source</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%9E%84%E9%80%A0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">构造回调函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%88%9B%E5%BB%BA-scheduler"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">创建 scheduler</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%88%9B%E5%BB%BA-effect"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">创建 effect</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%BF%94%E5%9B%9E%E9%94%80%E6%AF%81%E5%87%BD%E6%95%B0"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">返回销毁函数</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">异步任务队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">异步任务队列的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">异步任务队列的创建</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">异步任务队列的执行</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A3%80%E6%B5%8B%E5%BE%AA%E7%8E%AF%E6%9B%B4%E6%96%B0"><span class="toc-nav-number">4.4.</span> <span class="toc-nav-text">检测循环更新</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A%E5%8F%AA%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-nav-number">4.5.</span> <span class="toc-nav-text">优化：只用一个变量</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#watchEffect-API"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">watchEffect API</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%B3%A8%E5%86%8C%E6%97%A0%E6%95%88%E5%87%BD%E6%95%B0"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">注册无效函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">总结</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">FEATURED TAGS</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#vue3源码" title="vue3源码">vue3源码</a>
            
            <a class="tag" href="/tags/#vue3" title="vue3">vue3</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Jason Luo
          2021
          <br>
          Theme by
          <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="/js/mouseclick.js" content='我要变强，为此不惜一切...,一念往，尽作尘泥罢...,玻璃晴朗，橘子辉煌...,我心即地狱，管他罪孽滔天...,我要这天，再遮不住我眼...,我要这地，再埋不了我心...,斯若晴空，何惧冰寒...,这灯红酒绿的世界啊...,不要放弃，哪怕付出所有...' color='#CDF0EA,#F9F9F9,#F7DBF0,#BEAEE2,#F38181,#FCE38A,#EAFFD0,#95E1D3,#80D6FF'></script>
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="/js/ribbonDynamic.js"></script>
  

  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("https://jasonluox.github.io/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="SEARCH..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"mobile":{"show":"fasle"},"display":{"hOffset":-40,"vOffset":-80},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
